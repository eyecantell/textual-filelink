File listing generated 2025-12-21T20:08:42.213329 by prepdir version 0.18.0 (pip install prepdir)
Base directory is '/workspaces/textual-filelink/src/textual_filelink'
Note: Valid (hyphenated) UUIDs in file contents will be scrubbed and replaced with '00000000-0000-0000-0000-000000000000'.
Note: Valid hyphen-less UUIDs in file contents will be scrubbed and replaced with '00000000000000000000000000000000'.
=-=-=-=-=-=-=-= Begin File: '__init__.py' =-=-=-=-=-=-=-=
from .command_link import CommandLink
from .file_link import FileLink
from .toggleable_file_link import ToggleableFileLink

__all__ = ["FileLink", "ToggleableFileLink", "CommandLink"]

=-=-=-=-=-=-=-= End File: '__init__.py' =-=-=-=-=-=-=-=
=-=-=-=-=-=-=-= Begin File: 'command_link.py' =-=-=-=-=-=-=-=
from __future__ import annotations

import contextlib
import logging
from pathlib import Path
from typing import Callable

from textual import on
from textual.binding import Binding
from textual.message import Message
from textual.timer import Timer

from .toggleable_file_link import ToggleableFileLink

logger = logging.getLogger(__name__)


class CommandLink(ToggleableFileLink):
    """A specialized widget for command orchestration and status display.

    Layout: [toggle] [status/spinner] [play/stop] command_name [settings] [remove]

    The widget is fully controlled by the parent - it displays state and emits
    events for user interactions. Single-instance commands only (not multiple
    concurrent runs of the same command).

    Event Bubbling Policy
    ---------------------
    - Internal click handlers stop event propagation with event.stop()
    - Widget-specific messages (PlayClicked, StopClicked, SettingsClicked) bubble up by default
    - Parent containers can handle or stop these messages as needed

    Example:
        ```python
        link = CommandLink(
            "Tests",
            output_path=None,
            initial_status_icon="❓",
            initial_status_tooltip="Not run",
        )

        # When command starts
        link.set_status(running=True, tooltip="Running tests...")

        # When command completes
        link.set_status(icon="✅", running=False, tooltip="Passed")
        link.set_output_path(Path("test_output.log"))
        ```
    """

    # Keyboard bindings for CommandLink-specific actions
    BINDINGS = [
        Binding("o", "open_output", "Open output", show=False),
        Binding("space", "play_stop", "Play/Stop", show=False),
        Binding("p", "play_stop", "Play/Stop", show=False),
        Binding("s", "settings", "Settings", show=False),
        # Inherit t/x/delete from parent but allow override
        Binding("t", "toggle", "Toggle", show=False, priority=True),
        Binding("x", "remove", "Remove", show=False, priority=True),
        Binding("delete", "remove", "Remove", show=False, priority=True),
    ]

    # Spinner frames for animation
    SPINNER_FRAMES = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]

    @staticmethod
    def sanitize_id(name: str) -> str:
        """Convert command name to valid widget ID.

        Sanitizes the name for use as a Textual widget ID by converting to
        lowercase, replacing spaces with hyphens, and removing invalid characters.

        Parameters
        ----------
        name : str
            Command name (can contain spaces, special characters, etc.)

        Returns
        -------
        str
            Sanitized ID containing only alphanumeric characters, hyphens, and underscores.

        Examples
        --------
        >>> CommandLink.sanitize_id("Format Code")
        'format-code'
        >>> CommandLink.sanitize_id("Run Tests")
        'run-tests'
        >>> CommandLink.sanitize_id("Build-Project!")
        'build-project-'
        """
        # Convert to lowercase and replace spaces with hyphens
        sanitized = name.lower().replace(" ", "-")
        # Keep only alphanumeric, hyphens, and underscores
        return "".join(char if char.isalnum() or char in ("-", "_") else "-" for char in sanitized)

    class PlayClicked(Message):
        """Posted when play button is clicked.

        Attributes
        ----------
        path : Path | None
            The output file path, or None if not set.
        name : str
            The command name.
        output_path : Path | None
            The output file path (same as path for consistency).
        is_toggled : bool
            Whether the command is toggled/selected.
        """

        def __init__(self, path: Path | None, name: str, output_path: Path | None, is_toggled: bool) -> None:
            super().__init__()
            self.path = path
            self.name = name
            self.output_path = output_path
            self.is_toggled = is_toggled

    class StopClicked(Message):
        """Posted when stop button is clicked.

        Attributes
        ----------
        path : Path | None
            The output file path, or None if not set.
        name : str
            The command name.
        output_path : Path | None
            The output file path (same as path for consistency).
        is_toggled : bool
            Whether the command is toggled/selected.
        """

        def __init__(self, path: Path | None, name: str, output_path: Path | None, is_toggled: bool) -> None:
            super().__init__()
            self.path = path
            self.name = name
            self.output_path = output_path
            self.is_toggled = is_toggled

    class SettingsClicked(Message):
        """Posted when settings icon is clicked.

        Attributes
        ----------
        path : Path | None
            The output file path, or None if not set.
        name : str
            The command name.
        output_path : Path | None
            The output file path (same as path for consistency).
        is_toggled : bool
            Whether the command is toggled/selected.
        """

        def __init__(self, path: Path | None, name: str, output_path: Path | None, is_toggled: bool) -> None:
            super().__init__()
            self.path = path
            self.name = name
            self.output_path = output_path
            self.is_toggled = is_toggled

    def __init__(
        self,
        name: str,
        output_path: Path | str | None = None,
        *,
        initial_toggle: bool = False,
        initial_status_icon: str = "❓",
        initial_status_tooltip: str | None = None,
        running: bool = False,
        show_toggle: bool = True,
        show_settings: bool = True,
        show_remove: bool = True,
        toggle_tooltip: str | None = None,
        settings_tooltip: str | None = None,
        remove_tooltip: str | None = None,
        link_tooltip: str | None = None,
        command_builder: Callable | None = None,
        disable_on_untoggle: bool = False,
    ) -> None:
        """
        Parameters
        ----------
        name : str
            Command display name (also used as widget ID).
        output_path : Path | str | None
            Path to output file. If None, clicking command name does nothing.
        initial_toggle : bool
            Whether the command starts toggled/selected (default: False).
        initial_status_icon : str
            Initial status icon (default: "❓" for not run).
        initial_status_tooltip : str | None
            Initial tooltip for status icon.
        running : bool
            Whether command is currently running (default: False).
            If True, shows spinner and stop button instead of status icon and play button.
        show_toggle : bool
            Whether to show the toggle checkbox (default: True).
        show_settings : bool
            Whether to show the settings icon (default: True).
        show_remove : bool
            Whether to show the remove button (default: True).
        toggle_tooltip : str | None
            Tooltip for toggle checkbox.
        settings_tooltip : str | None
            Tooltip for settings icon.
        remove_tooltip : str | None
            Tooltip for remove button.
        link_tooltip : str | None
            Tooltip for the command name itself.
        command_builder : Callable | None
            Custom command builder for opening output files.
        disable_on_untoggle : bool
            If True, dim/disable when untoggled (default: False).
        """
        self._name = name
        self._output_path = Path(output_path) if output_path else None
        self._command_running = running  # Set BEFORE calling super().__init__()
        self._show_settings = show_settings
        self._status_icon = initial_status_icon
        self._status_tooltip = initial_status_tooltip
        self._spinner_timer: Timer | None = None
        self._spinner_frame = 0

        logger.debug(
            f"Initializing CommandLink: {self._name}, running={self._command_running}, output_path={self._output_path}"
        )

        # Build icons list for parent ToggleableFileLink
        icons = []

        # Status icon (or will be replaced by spinner if running)
        icons.append(
            {
                "name": "status",
                "icon": initial_status_icon,
                "tooltip": initial_status_tooltip,
                "position": "before",
                "index": 0,
                "visible": not running,  # Hide if running (spinner will show instead)
            }
        )

        # Play/Stop button
        play_stop_icon = "⏹️" if running else "▶️"
        play_stop_tooltip_base = "Stop command" if running else "Run command"
        icons.append(
            {
                "name": "play_stop",
                "icon": play_stop_icon,
                "tooltip": play_stop_tooltip_base,  # Will be enhanced with keyboard shortcut
                "position": "before",
                "index": 1,
                "clickable": True,
            }
        )

        # Settings icon (after command name)
        if show_settings:
            icons.append(
                {
                    "name": "settings",
                    "icon": "⚙",
                    "tooltip": settings_tooltip or "Settings",
                    "position": "after",
                    "index": 0,
                    "clickable": True,
                }
            )

        # Determine command builder - use no-op if no output path
        if output_path is None and command_builder is None:
            command_builder = CommandLink._noop_command_builder

        # Use command name as display text (parent will show path.name)
        display_path = Path(name)

        # Sanitize command name for use as widget ID
        # (converts spaces to hyphens, removes invalid characters)
        sanitized_id = CommandLink.sanitize_id(name)

        # Initialize parent
        super().__init__(
            display_path,
            initial_toggle=initial_toggle,
            show_toggle=show_toggle,
            show_remove=show_remove,
            icons=icons,
            toggle_tooltip=toggle_tooltip,
            remove_tooltip=remove_tooltip,
            link_tooltip=link_tooltip,
            command_builder=command_builder,
            disable_on_untoggle=disable_on_untoggle,
            id=sanitized_id,  # Use sanitized name as ID for easy lookup
            name=None,  # Don't set Widget.name, we use our own _name
        )

        logger.debug(
            f"CommandLink after super init: {self._name}, running={self._command_running}, output_path={self._output_path}"
        )

    @staticmethod
    def _noop_command_builder(_path: Path, _line: int | None, _column: int | None) -> list[str]:
        """No-op command builder when no output file exists."""
        return ["true"]  # Unix no-op command

    def set_status(
        self,
        icon: str | None = None,
        tooltip: str | None = None,
        running: bool | None = None,
    ) -> None:
        """Update command status display.

        Parameters
        ----------
        icon : str | None
            Status icon to display. If None and running=True, shows spinner.
        tooltip : str | None
            Tooltip for status icon/spinner.
        running : bool | None
            Update running state. If True, shows stop button; if False, shows play button.

        Examples
        --------
        >>> link.set_status(running=True, tooltip="Running tests...")
        >>> link.set_status(icon="✅", running=False, tooltip="All tests passed")
        >>> link.set_status(icon="❌", tooltip="3 tests failed")  # Update icon only
        """
        # Update running state
        if running is not None:
            self._command_running = running
            logger.debug(f"CommandLink '{self._name}' running state set to {running}")

            # Update play/stop button (tooltip will be enhanced with keyboard shortcut)
            play_stop_icon = "⏹️" if running else "▶️"
            play_stop_tooltip_base = "Stop command" if running else "Run command"
            self.update_icon("play_stop", icon=play_stop_icon, tooltip=play_stop_tooltip_base)

        # Update status icon/spinner
        if icon is not None:
            self._status_icon = icon
            self._status_tooltip = tooltip
            # Show the icon (stop spinner if it was showing)
            self._stop_spinner()
            self.set_icon_visible("status", True)
            self.update_icon("status", icon=icon, tooltip=tooltip)
        elif tooltip is not None:
            # Update tooltip only
            self._status_tooltip = tooltip
            if self.get_icon("status")["visible"]:
                self.update_icon("status", tooltip=tooltip)

        # Handle spinner visibility
        if running is not None:
            if running and icon is None:
                # Show spinner, hide status icon
                self.set_icon_visible("status", False)
                self._start_spinner()
            elif not running:
                # Stop spinner, show status icon
                self._stop_spinner()
                self.set_icon_visible("status", True)
                if self._status_icon:
                    self.update_icon("status", icon=self._status_icon, tooltip=self._status_tooltip)

    def _start_spinner(self) -> None:
        """Start the spinner animation."""
        if self._spinner_timer is None:
            self._spinner_frame = 0
            # Update immediately
            self.update_icon("status", icon=self.SPINNER_FRAMES[0], tooltip=self._status_tooltip)
            self.set_icon_visible("status", True)
            # Start timer for animation (10 FPS)
            self._spinner_timer = self.set_interval(0.1, self._animate_spinner)

    def _stop_spinner(self) -> None:
        """Stop the spinner animation."""
        if self._spinner_timer is not None:
            self._spinner_timer.stop()
            self._spinner_timer = None
            self._spinner_frame = 0

    def _animate_spinner(self) -> None:
        """Animate the spinner by cycling through frames."""
        self._spinner_frame = (self._spinner_frame + 1) % len(self.SPINNER_FRAMES)
        try:
            self.update_icon("status", icon=self.SPINNER_FRAMES[self._spinner_frame])
        except KeyError:
            # Icon was removed, stop the spinner
            self._stop_spinner()

    def set_output_path(
        self,
        path: Path | str | None,
        tooltip: str | None = None,
    ) -> None:
        """Update the output file path and optionally its tooltip.

        Parameters
        ----------
        path : Path | str | None
            New output file path. If None, clicking command name does nothing.
        tooltip : str | None
            New tooltip for the command name/file link.

        Examples
        --------
        >>> link.set_output_path(Path("output.log"), tooltip="Click to view output")
        >>> link.set_output_path(None)  # Clear output path
        """
        self._output_path = Path(path) if path else None

        # Update the internal FileLink via the new property (only if mounted)
        try:
            file_link = self.file_link
            file_link._path = self._output_path if self._output_path else Path(self._name)

            # Update command builder
            if self._output_path is None:
                file_link._command_builder = CommandLink._noop_command_builder
            else:
                file_link._command_builder = None  # Use default

            # Update tooltip if provided (enhance with keyboard shortcut)
            if tooltip is not None:
                file_link.tooltip = self._enhance_tooltip(tooltip, "open_output")
        except Exception:
            # Widget not mounted yet, changes will apply when mounted
            pass

    def set_toggle(
        self,
        toggled: bool,
        tooltip: str | None = None,
    ) -> None:
        """Update toggle state and optionally its tooltip.

        Parameters
        ----------
        toggled : bool
            New toggle state.
        tooltip : str | None
            New tooltip for the toggle checkbox.

        Examples
        --------
        >>> link.set_toggle(True, tooltip="Selected for batch run")
        >>> link.set_toggle(False)
        """
        # Update internal state
        self._is_toggled = toggled

        # Update the toggle display
        try:
            toggle_static = self.query_one("#toggle")
            toggle_static.update("☑" if toggled else "☐")

            if tooltip is not None:
                toggle_static.tooltip = tooltip
        except Exception:
            pass

        # Update disabled state if needed
        self._update_disabled_state()

    def set_settings_tooltip(self, tooltip: str | None) -> None:
        """Update settings icon tooltip.

        Parameters
        ----------
        tooltip : str | None
            New tooltip text, or None to remove tooltip.

        Examples
        --------
        >>> link.set_settings_tooltip("Configure test options")
        """
        if self._show_settings:
            with contextlib.suppress(KeyError):
                self.update_icon("settings", tooltip=tooltip or "Settings")

    # ------------------------------------------------------------------ #
    # Keyboard handling
    # ------------------------------------------------------------------ #
    def action_open_output(self) -> None:
        """Open output file via keyboard."""
        if self._output_path:
            # Delegate to parent's action_open_file
            super().action_open_file()

    def action_play_stop(self) -> None:
        """Toggle play/stop via keyboard."""
        if self._command_running:
            # Stop command
            self.post_message(
                self.StopClicked(
                    path=self._output_path,
                    name=self.name,
                    output_path=self._output_path,
                    is_toggled=self._is_toggled,
                )
            )
        else:
            # Play command
            self.post_message(
                self.PlayClicked(
                    path=self._output_path,
                    name=self.name,
                    output_path=self._output_path,
                    is_toggled=self._is_toggled,
                )
            )

    def action_settings(self) -> None:
        """Open settings via keyboard."""
        if not self._show_settings:
            return
        self.post_message(
            self.SettingsClicked(
                path=self._output_path,
                name=self.name,
                output_path=self._output_path,
                is_toggled=self._is_toggled,
            )
        )

    def action_toggle(self) -> None:
        """Toggle via keyboard - call parent implementation."""
        super().action_toggle()

    def action_remove(self) -> None:
        """Remove via keyboard - call parent implementation."""
        super().action_remove()

    def on_unmount(self) -> None:
        """Clean up spinner timer when widget is unmounted."""
        self._stop_spinner()

    @on(ToggleableFileLink.IconClicked)
    def _handle_icon_click(self, event: ToggleableFileLink.IconClicked) -> None:
        """Handle icon clicks - convert to CommandLink-specific messages."""
        icon_name = event.icon_name

        # Stop the event from bubbling further
        event.stop()

        if icon_name == "play_stop":
            if self._command_running:
                self.post_message(
                    self.StopClicked(
                        path=self._output_path,
                        name=self.name,
                        output_path=self._output_path,
                        is_toggled=self._is_toggled,
                    )
                )
            else:
                self.post_message(
                    self.PlayClicked(
                        path=self._output_path,
                        name=self.name,
                        output_path=self._output_path,
                        is_toggled=self._is_toggled,
                    )
                )
        elif icon_name == "settings":
            self.post_message(
                self.SettingsClicked(
                    path=self._output_path, name=self.name, output_path=self._output_path, is_toggled=self._is_toggled
                )
            )

    @property
    def display_name(self) -> str:
        """Get the command display name.

        Returns
        -------
        str
            The command name used for display.
        """
        return self._name

    @property
    def name(self) -> str:
        """Get the command name (alias for display_name).

        Returns
        -------
        str
            The command name.
        """
        return self.id or self._name

    @property
    def path(self) -> Path | None:
        """Get the output file path.

        This overrides the parent's path property to return the actual
        output file path instead of a display path.

        Returns
        -------
        Path | None
            The output file path, or None if not set.
        """
        return self._output_path

    @property
    def output_path(self) -> Path | None:
        """Get the current output file path.

        Returns
        -------
        Path | None
            The output file path, or None if not set.
        """
        return self._output_path

    @property
    def is_running(self) -> bool:
        """Get whether the command is currently running."""
        return self._command_running

=-=-=-=-=-=-=-= End File: 'command_link.py' =-=-=-=-=-=-=-=
=-=-=-=-=-=-=-= Begin File: 'file_link.py' =-=-=-=-=-=-=-=
from __future__ import annotations

import os
import subprocess
from pathlib import Path
from typing import Callable

from textual import events
from textual.binding import Binding
from textual.message import Message
from textual.widgets import Static


class FileLink(Static, can_focus=True):
    """Clickable filename that opens the real file using a configurable command.

    Event Bubbling Policy
    ---------------------
    - Internal click handlers stop event propagation with event.stop()
    - Widget-specific messages (Clicked) bubble up by default
    - Parent containers can handle or stop these messages as needed
    """

    BINDINGS = [
        Binding("o", "open_file", "Open file", show=False),
    ]

    DEFAULT_CSS = """
    FileLink {
        width: auto;
        height: 1;
        color: $primary;
        text-style: underline;
        background: transparent;
        padding: 0;
        border: none;
    }
    FileLink:hover {
        text-style: bold underline;
        background: $boost;
    }
    FileLink:focus {
        background: $accent 20%;
        border: tall $accent;
    }
    """

    # Class-level default command builder
    default_command_builder: Callable | None = None

    class Clicked(Message):
        """Posted when the link is activated.

        Attributes
        ----------
        path : Path
            The file path that was clicked.
        line : int | None
            The line number to navigate to, or None.
        column : int | None
            The column number to navigate to, or None.
        """

        def __init__(self, path: Path, line: int | None, column: int | None) -> None:
            super().__init__()
            self.path = path
            self.line = line
            self.column = column

    def __init__(
        self,
        path: Path | str,
        *,
        line: int | None = None,
        column: int | None = None,
        command_builder: Callable | None = None,
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
        _embedded: bool = False,
        tooltip: str | None = None,
    ) -> None:
        """
        Parameters
        ----------
        path : Path | str
            Full path to the file.
        line, column : int | None
            Optional cursor position to jump to.
        command_builder : Callable | None
            Function that takes (path, line, column) and returns a list of command arguments.
            If None, uses the class-level default_command_builder.
            If that's also None, uses VSCode's 'code --goto' command.
        _embedded : bool
            Internal use only. If True, disables focus to prevent stealing focus from parent widget.
        tooltip : str | None
            Optional tooltip text. If provided, will be enhanced with keyboard shortcuts.
        """
        self._path = Path(path).resolve()
        self._line = line
        self._column = column
        self._command_builder = command_builder

        # Initialize Static with the filename as content
        super().__init__(
            self._path.name,
            name=name,
            id=id,
            classes=classes,
        )

        # Disable focus if embedded in parent widget to prevent focus stealing
        if _embedded:
            self.can_focus = False
        else:
            # Set enhanced tooltip for standalone FileLink
            default_tooltip = f"Open {self._path.name}"
            enhanced = self._enhance_tooltip(tooltip or default_tooltip, "open_file")
            self.tooltip = enhanced

    # ------------------------------------------------------------------ #
    # Keyboard handling
    # ------------------------------------------------------------------ #
    def action_open_file(self) -> None:
        """Open file via keyboard (reuses existing click logic)."""
        self._do_open_file()

    def _get_keys_for_action(self, action_name: str) -> list[str]:
        """Get all keys bound to an action.

        Args:
            action_name: The action name (e.g., 'open_file', 'toggle')

        Returns:
            List of key names bound to the action (e.g., ['o'], ['space', 't'])
        """
        keys = []
        for binding in self.BINDINGS:
            if binding.action == action_name:
                keys.append(binding.key)
        return keys

    def _enhance_tooltip(self, base_tooltip: str | None, action_name: str) -> str:
        """Enhance tooltip with keyboard shortcut hints.

        Args:
            base_tooltip: The base tooltip text (or None)
            action_name: The action name to get keys for

        Returns:
            Enhanced tooltip with keyboard shortcuts appended

        Examples:
            _enhance_tooltip("Click to toggle", "toggle")
            → "Click to toggle (space/t)"

            _enhance_tooltip(None, "open_file")
            → "Open file (o)"
        """
        keys = self._get_keys_for_action(action_name)

        if not keys:
            # No keys bound, return base tooltip or empty string
            return base_tooltip or ""

        # Format keys as "key1/key2/key3"
        key_hint = "/".join(keys)

        # If no base tooltip, generate sensible default
        if not base_tooltip:
            # Convert action_name to readable text
            # "open_file" → "Open file"
            # "play_stop" → "Play/Stop"
            readable = action_name.replace("_", " ").title()
            base_tooltip = readable

        return f"{base_tooltip} ({key_hint})"

    # ------------------------------------------------------------------ #
    # Mouse handling for clickability
    # ------------------------------------------------------------------ #
    def on_click(self, event: events.Click) -> None:
        """Handle click event."""
        event.stop()
        self.post_message(self.Clicked(self._path, self._line, self._column))
        self._do_open_file()

    def _do_open_file(self) -> None:
        """Open the file (shared logic for click and keyboard activation)."""
        # Determine which command builder to use
        command_builder = self._command_builder or self.default_command_builder or self.vscode_command

        # Open the file directly (it's fast enough not to block)
        try:
            cmd = command_builder(self._path, self._line, self._column)

            result = subprocess.run(
                cmd, env=os.environ.copy(), cwd=str(Path.cwd()), capture_output=True, text=True, timeout=5
            )

            if result.returncode == 0:
                self.app.notify(f"Opened {self._path.name}", title="FileLink", timeout=1.5)
            else:
                error_msg = result.stderr.strip() if result.stderr else f"Exit code {result.returncode}"
                self.app.notify(f"Failed to open {self._path.name}: {error_msg}", severity="error", timeout=3)

        except subprocess.TimeoutExpired:
            self.app.notify(f"Timeout opening {self._path.name}", severity="error", timeout=3)
        except Exception as exc:
            self.app.notify(f"Failed to open {self._path.name}: {exc}", severity="error", timeout=3)

    # ------------------------------------------------------------------ #
    # Default command builders
    # ------------------------------------------------------------------ #
    @staticmethod
    def vscode_command(path: Path, line: int | None, column: int | None) -> list[str]:
        """Build VSCode 'code --goto' command."""
        try:
            cwd = Path.cwd()
            relative_path = path.relative_to(cwd)
            file_arg = str(relative_path)
        except ValueError:
            file_arg = str(path)

        if line is not None:
            goto_arg = f"{file_arg}:{line}"
            if column is not None:
                goto_arg += f":{column}"
        else:
            goto_arg = file_arg

        return ["code", "--goto", goto_arg]

    @staticmethod
    def vim_command(path: Path, line: int | None, column: int | None) -> list[str]:
        """Build vim command."""
        cmd = ["vim"]
        if line is not None:
            if column is not None:
                cmd.append(f"+call cursor({line},{column})")
            else:
                cmd.append(f"+{line}")
        cmd.append(str(path))
        return cmd

    @staticmethod
    def nano_command(path: Path, line: int | None, column: int | None) -> list[str]:
        """Build nano command."""
        cmd = ["nano"]
        if line is not None:
            if column is not None:
                cmd.append(f"+{line},{column}")
            else:
                cmd.append(f"+{line}")
        cmd.append(str(path))
        return cmd

    @staticmethod
    def eclipse_command(path: Path, line: int | None, column: int | None) -> list[str]:
        """Build Eclipse command."""
        cmd = ["eclipse"]
        if line is not None:
            cmd.extend(["--launcher.openFile", f"{path}:{line}"])
        else:
            cmd.extend(["--launcher.openFile", str(path)])
        return cmd

    @staticmethod
    def copy_path_command(path: Path, line: int | None, column: int | None) -> list[str]:
        """Copy the full path (with line:column) to clipboard."""
        import platform

        path_str = str(path)
        if line is not None:
            path_str += f":{line}"
            if column is not None:
                path_str += f":{column}"

        system = platform.system()
        if system == "Darwin":
            return ["bash", "-c", f"echo -n '{path_str}' | pbcopy"]
        elif system == "Windows":
            return ["cmd", "/c", f"echo {path_str} | clip"]
        else:
            return [
                "bash",
                "-c",
                f"echo -n '{path_str}' | xclip -selection clipboard 2>/dev/null || echo -n '{path_str}' | xsel --clipboard",
            ]

    # ------------------------------------------------------------------ #
    # Properties
    # ------------------------------------------------------------------ #
    @property
    def path(self) -> Path:
        """Get the file path."""
        return self._path

    @property
    def line(self) -> int | None:
        """Get the line number."""
        return self._line

    @property
    def column(self) -> int | None:
        """Get the column number."""
        return self._column

=-=-=-=-=-=-=-= End File: 'file_link.py' =-=-=-=-=-=-=-=
=-=-=-=-=-=-=-= Begin File: 'toggleable_file_link.py' =-=-=-=-=-=-=-=
from __future__ import annotations

import logging
import warnings
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Callable, Literal

from textual import events, on
from textual.app import ComposeResult
from textual.binding import Binding
from textual.containers import Horizontal
from textual.message import Message
from textual.widget import Widget
from textual.widgets import Static

from .file_link import FileLink

logger = logging.getLogger(__name__)


@dataclass
class IconConfig:
    """Configuration for a status icon in ToggleableFileLink."""

    name: str
    icon: str
    position: Literal["before", "after"] = "before"
    index: int | None = None
    visible: bool = True
    clickable: bool = False
    tooltip: str | None = None


class ToggleableFileLink(Widget, can_focus=True):
    """A FileLink with optional toggle (☐/☑) on the left, multiple status icons, and optional remove (×) on the right.

    Event Bubbling Policy
    ---------------------
    - Internal click handlers stop event propagation with event.stop()
    - Widget-specific messages (Toggled, Removed, IconClicked) bubble up by default
    - Parent containers can handle or stop these messages as needed
    """

    BINDINGS = [
        Binding("o", "open_file", "Open file", show=False),
        Binding("space", "toggle", "Toggle", show=False),
        Binding("t", "toggle", "Toggle", show=False),
        Binding("delete", "remove", "Remove", show=False),
        Binding("x", "remove", "Remove", show=False),
        Binding("1", "icon_1", "Icon 1", show=False),
        Binding("2", "icon_2", "Icon 2", show=False),
        Binding("3", "icon_3", "Icon 3", show=False),
        Binding("4", "icon_4", "Icon 4", show=False),
        Binding("5", "icon_5", "Icon 5", show=False),
        Binding("6", "icon_6", "Icon 6", show=False),
        Binding("7", "icon_7", "Icon 7", show=False),
        Binding("8", "icon_8", "Icon 8", show=False),
        Binding("9", "icon_9", "Icon 9", show=False),
    ]

    DEFAULT_CSS = """
    ToggleableFileLink {
        height: auto;
        width: auto;
        min-width: 100%;
    }

    ToggleableFileLink:focus {
        background: $accent 20%;
        border: tall $accent;
    }

    ToggleableFileLink Horizontal {
        height: auto;
        width: auto;
        align: left middle;
    }

    ToggleableFileLink .toggle-static {
        width: 3;
        max-width: 3;
        height: auto;
        background: transparent;
        border: none;
        padding: 0;
        color: $text;
        content-align: center middle;
    }

    ToggleableFileLink .toggle-static:hover {
        background: $boost;
    }

    ToggleableFileLink .status-icon {
        width: 5;
        max-width: 5;
        height: auto;
        background: transparent;
        border: none;
        padding: 0;
        color: $text;
        content-align: center middle;
    }

    ToggleableFileLink .status-icon:hover {
        background: $boost;
    }

    ToggleableFileLink .status-icon.clickable {
        text-style: underline;
    }

    ToggleableFileLink .file-link-container {
        width: 1fr;
        height: auto;
    }

    ToggleableFileLink .file-link-container FileLink {
        text-align: left;
    }

    ToggleableFileLink .remove-static {
        width: 3;
        max-width: 3;
        height: auto;
        background: transparent;
        border: none;
        padding: 0;
        color: $error;
        content-align: center middle;
    }

    ToggleableFileLink .remove-static:hover {
        background: $boost;
        color: $error;
    }

    ToggleableFileLink.disabled {
        opacity: 0.5;
    }

    ToggleableFileLink.disabled .file-link-container {
        text-style: dim;
    }
    """

    class Toggled(Message):
        """Posted when the toggle state changes.

        Attributes
        ----------
        path : Path
            The file path of the toggled widget.
        is_toggled : bool
            The new toggle state (True if toggled on, False if toggled off).
        """

        def __init__(self, path: Path, is_toggled: bool) -> None:
            super().__init__()
            self.path = path
            self.is_toggled = is_toggled

    class Removed(Message):
        """Posted when the remove button is clicked.

        Attributes
        ----------
        path : Path
            The file path of the widget to be removed.
        """

        def __init__(self, path: Path) -> None:
            super().__init__()
            self.path = path

    class IconClicked(Message):
        """Posted when a status icon is clicked.

        Attributes
        ----------
        path : Path
            The file path of the widget containing the icon.
        icon_name : str
            The name identifier of the clicked icon.
        icon : str
            The icon character/emoji that was clicked.
        """

        def __init__(self, path: Path, icon_name: str, icon: str) -> None:
            super().__init__()
            self.path = path
            self.icon_name = icon_name
            self.icon = icon

    def __init__(
        self,
        path: Path | str,
        *,
        initial_toggle: bool = False,
        show_toggle: bool = True,
        show_remove: bool = True,
        icons: list[IconConfig | dict] | None = None,
        line: int | None = None,
        column: int | None = None,
        command_builder: Callable | None = None,
        disable_on_untoggle: bool = False,
        toggle_tooltip: str | None = None,
        remove_tooltip: str | None = None,
        link_tooltip: str | None = None,
        # Deprecated parameters for backwards compatibility
        status_icon: str | None = None,
        status_icon_clickable: bool = False,
        status_tooltip: str | None = None,
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
    ) -> None:
        """
        Parameters
        ----------
        path : Path | str
            Full path to the file.
        initial_toggle : bool
            Whether the item starts toggled (checked).
        show_toggle : bool
            Whether to display the toggle component (default: True).
        show_remove : bool
            Whether to display the remove component (default: True).
        icons : list[IconConfig | dict] | None
            List of icon configurations. Each can be an IconConfig dataclass or a dict with keys:
            - name (str, required): Unique identifier for the icon
            - icon (str, required): Unicode character to display
            - position (str, optional): "before" or "after" the filename (default: "before")
            - index (int | None, optional): Explicit ordering index (default: None = use list order)
            - visible (bool, optional): Whether icon is initially visible (default: True)
            - clickable (bool, optional): Whether icon posts IconClicked messages (default: False)
            - tooltip (str | None, optional): Tooltip text (default: None)
        line, column : int | None
            Optional cursor position to jump to.
        command_builder : Callable | None
            Function for opening the file.
        disable_on_untoggle : bool
            If True, dim/disable the link when untoggled.
        toggle_tooltip : str | None
            Tooltip text for the toggle button.
        remove_tooltip : str | None
            Tooltip text for the remove button.
        link_tooltip : str | None
            Tooltip text for the filename/link itself.
        status_icon : str | None
            [DEPRECATED] Use icons parameter instead. Unicode icon to display before filename.
        status_icon_clickable : bool
            [DEPRECATED] Use icons parameter instead.
        status_tooltip : str | None
            [DEPRECATED] Use icons parameter instead.
        """
        super().__init__(name=name, id=id, classes=classes)
        self._path = Path(path).resolve()
        self._is_toggled = initial_toggle
        self._show_toggle = show_toggle
        self._show_remove = show_remove
        self._line = line
        self._column = column
        self._command_builder = command_builder
        self._disable_on_untoggle = disable_on_untoggle
        self._toggle_tooltip = toggle_tooltip
        self._remove_tooltip = remove_tooltip
        self._link_tooltip = link_tooltip
        logger.debug(
            f"ToggleableFileLink initialized with path: {self._path}, initial_toggle: {initial_toggle}, show_toggle: {show_toggle}, show_remove: {show_remove}"
        )

        # Handle backwards compatibility for old status_icon parameters
        if status_icon is not None:
            warnings.warn(
                "status_icon, status_icon_clickable, and status_tooltip are deprecated. "
                "Use the icons parameter instead.",
                DeprecationWarning,
                stacklevel=2,
            )
            if icons is None:
                icons = []
            icons.append(
                {
                    "name": "status",
                    "icon": status_icon,
                    "clickable": status_icon_clickable,
                    "tooltip": status_tooltip,
                    "position": "before",
                }
            )

        # Convert icons to IconConfig dataclasses and validate
        self._icons: list[IconConfig] = []
        if icons:
            self._icons = self._validate_and_convert_icons(icons)

    def _get_keys_for_action(self, action_name: str) -> list[str]:
        """Get all keys bound to an action.

        Args:
            action_name: The action name (e.g., 'open_file', 'toggle')

        Returns:
            List of key names bound to the action (e.g., ['o'], ['space', 't'])
        """
        keys = []
        for binding in self.BINDINGS:
            if binding.action == action_name:
                keys.append(binding.key)
        return keys

    def _enhance_tooltip(self, base_tooltip: str | None, action_name: str) -> str:
        """Enhance tooltip with keyboard shortcut hints.

        Args:
            base_tooltip: The base tooltip text (or None)
            action_name: The action name to get keys for

        Returns:
            Enhanced tooltip with keyboard shortcuts appended
        """
        keys = self._get_keys_for_action(action_name)

        if not keys:
            # No keys bound, return base tooltip or empty string
            return base_tooltip or ""

        # Format keys as "key1/key2/key3"
        key_hint = "/".join(keys)

        # If no base tooltip, generate sensible default
        if not base_tooltip:
            # Convert action_name to readable text
            readable = action_name.replace("_", " ").title()
            base_tooltip = readable

        return f"{base_tooltip} ({key_hint})"

    def _validate_and_convert_icons(self, icons: list[IconConfig | dict]) -> list[IconConfig]:
        """Validate and convert icon configs to IconConfig dataclasses."""
        result = []
        seen_names = set()

        for i, icon_data in enumerate(icons):
            # Convert dict to IconConfig if needed
            if isinstance(icon_data, dict):
                # Validate required fields
                if "name" not in icon_data:
                    raise ValueError(f"Icon at index {i} missing required field 'name'")
                if "icon" not in icon_data:
                    raise ValueError(f"Icon at index {i} missing required field 'icon'")

                # Validate position if provided
                position = icon_data.get("position", "before")
                if position not in ("before", "after"):
                    raise ValueError(
                        f"Icon '{icon_data['name']}' has invalid position '{position}'. Must be 'before' or 'after'."
                    )

                icon_config = IconConfig(**icon_data)
            elif isinstance(icon_data, IconConfig):
                icon_config = icon_data
            else:
                raise ValueError(f"Icon at index {i} must be IconConfig or dict, got {type(icon_data)}")

            # Check for duplicate names
            if icon_config.name in seen_names:
                raise ValueError(f"Duplicate icon name: '{icon_config.name}'")
            seen_names.add(icon_config.name)

            result.append(icon_config)

        return result

    def _sort_icons(self, icons: list[IconConfig], position: str) -> list[IconConfig]:
        """Sort icons by index (explicit first), then original list position, then name."""
        # Filter by position
        position_icons = [ic for ic in icons if ic.position == position]

        # Attach original position for stable sorting
        icons_with_pos = []
        for i, ic in enumerate(position_icons):
            icons_with_pos.append((i, ic))

        def sort_key(item):
            original_pos, ic = item
            idx = ic.index
            if idx is not None:
                return (0, idx, ic.name)  # Explicit indices first
            else:
                return (1, original_pos, ic.name)  # Then by list order, name for tiebreak

        sorted_icons = sorted(icons_with_pos, key=sort_key)
        return [ic for _, ic in sorted_icons]

    def compose(self) -> ComposeResult:
        with Horizontal():
            # Toggle
            if self._show_toggle:
                toggle_static = Static(
                    "☑" if self._is_toggled else "☐",
                    id="toggle",
                    classes="toggle-static",
                )
                toggle_static.tooltip = self._enhance_tooltip(self._toggle_tooltip, "toggle")
                yield toggle_static

            # Icons before filename
            before_icons = self._sort_icons(self._icons, "before")
            for icon_config in before_icons:
                if icon_config.visible:
                    yield self._create_icon_static(icon_config)

            # FileLink (with _embedded=True to prevent focus stealing)
            # Enhance tooltip with keyboard shortcut for open action
            enhanced_tooltip = self._enhance_tooltip(self._link_tooltip, "open_file")
            yield FileLink(
                self._path,
                line=self._line,
                column=self._column,
                command_builder=self._command_builder,
                classes="file-link-container",
                _embedded=True,
                tooltip=enhanced_tooltip if enhanced_tooltip else None,
            )

            # Icons after filename
            after_icons = self._sort_icons(self._icons, "after")
            for icon_config in after_icons:
                if icon_config.visible:
                    yield self._create_icon_static(icon_config)

            # Remove button
            if self._show_remove:
                remove_static = Static(
                    "×",
                    id="remove",
                    classes="remove-static",
                )
                remove_static.tooltip = self._enhance_tooltip(self._remove_tooltip, "remove")
                yield remove_static

    def _create_icon_static(self, icon_config: IconConfig) -> Static:
        """Create a Static widget for an icon."""
        classes = "status-icon"
        if icon_config.clickable:
            classes += " clickable"

        static = Static(
            icon_config.icon,
            id=f"icon-{icon_config.name}",
            classes=classes,
        )

        # Enhance tooltip with keyboard shortcut if clickable or special icons
        if icon_config.name == "settings":
            # Special case: settings uses 's' key, not a number
            static.tooltip = self._enhance_tooltip(icon_config.tooltip, "settings")
        elif icon_config.name == "play_stop":
            # Special case: play_stop uses 'p' and 'space' keys, not a number
            static.tooltip = self._enhance_tooltip(icon_config.tooltip, "play_stop")
        elif icon_config.clickable:
            # Find which number key activates this icon
            clickable_icons = [ic for ic in self._icons if ic.clickable and ic.visible]
            try:
                icon_index = clickable_icons.index(icon_config)
                icon_number = icon_index + 1  # 1-indexed
                if icon_number <= 9:
                    action_name = f"icon_{icon_number}"
                    static.tooltip = self._enhance_tooltip(icon_config.tooltip, action_name)
                else:
                    # No keyboard shortcut for icons beyond 9
                    static.tooltip = icon_config.tooltip or ""
            except ValueError:
                static.tooltip = icon_config.tooltip or ""
        else:
            static.tooltip = icon_config.tooltip or ""

        return static

    def on_mount(self) -> None:
        """Update initial disabled state."""
        self._update_disabled_state()

    def _update_disabled_state(self) -> None:
        """Update the disabled class based on toggle state."""
        if self._disable_on_untoggle and not self._is_toggled:
            self.add_class("disabled")
        else:
            self.remove_class("disabled")

    def set_icon_visible(self, name: str, visible: bool) -> None:
        """Show or hide a specific icon.

        Parameters
        ----------
        name : str
            The name of the icon to show/hide.
        visible : bool
            True to show, False to hide.

        Raises
        ------
        KeyError
            If no icon with the given name exists.
        """
        icon_config = self._get_icon_config(name)
        if icon_config is None:
            raise KeyError(f"No icon with name '{name}' found")

        icon_config.visible = visible

        # Update the DOM
        try:
            icon_static = self.query_one(f"#icon-{name}", Static)
            icon_static.display = visible
        except Exception:
            # Icon not yet mounted, will be handled in compose
            pass

    def update_icon(self, name: str, **kwargs) -> None:
        """Update properties of an existing icon.

        Parameters
        ----------
        name : str
            The name of the icon to update.
        **kwargs
            Properties to update: icon, position, index, visible, clickable, tooltip

        Raises
        ------
        KeyError
            If no icon with the given name exists.
        ValueError
            If an invalid property value is provided.

        Examples
        --------
        >>> link.update_icon("status", icon="✓", tooltip="Complete")
        >>> link.update_icon("warning", visible=False)
        """
        icon_config = self._get_icon_config(name)
        if icon_config is None:
            raise KeyError(f"No icon with name '{name}' found")

        # Validate position if provided
        if "position" in kwargs:
            position = kwargs["position"]
            if position not in ("before", "after"):
                raise ValueError(f"Invalid position '{position}'. Must be 'before' or 'after'.")

        # Update the config
        for key, value in kwargs.items():
            if hasattr(icon_config, key):
                setattr(icon_config, key, value)
            else:
                raise ValueError(f"Invalid property '{key}' for IconConfig")

        # If position or index changed, we need to recompose
        if "position" in kwargs or "index" in kwargs:
            # Schedule the recompose as a background task
            self.call_later(self._recompose_icons)
        else:
            # Update existing static widget
            try:
                icon_static = self.query_one(f"#icon-{name}", Static)

                if "icon" in kwargs:
                    icon_static.update(kwargs["icon"])

                if "tooltip" in kwargs:
                    new_tooltip = kwargs["tooltip"]

                    # Enhance with appropriate action name
                    if icon_config.name == "settings":
                        # Special case: settings uses 's' key
                        icon_static.tooltip = self._enhance_tooltip(new_tooltip, "settings")
                    elif icon_config.name == "play_stop":
                        # Special case: play_stop uses 'p' and 'space' keys
                        icon_static.tooltip = self._enhance_tooltip(new_tooltip, "play_stop")
                    elif icon_config.clickable:
                        # Find which number key activates this icon
                        clickable_icons = [ic for ic in self._icons if ic.clickable and ic.visible]
                        try:
                            icon_index = clickable_icons.index(icon_config)
                            icon_number = icon_index + 1
                            if icon_number <= 9:
                                action_name = f"icon_{icon_number}"
                                icon_static.tooltip = self._enhance_tooltip(new_tooltip, action_name)
                            else:
                                icon_static.tooltip = new_tooltip or ""
                        except ValueError:
                            icon_static.tooltip = new_tooltip or ""
                    else:
                        icon_static.tooltip = new_tooltip or ""

                if "visible" in kwargs:
                    icon_static.display = kwargs["visible"]

                if "clickable" in kwargs:
                    if kwargs["clickable"]:
                        icon_static.add_class("clickable")
                    else:
                        icon_static.remove_class("clickable")

            except Exception:
                # Icon not yet mounted or needs recompose
                pass

    async def _recompose_icons(self) -> None:
        """Recompose the entire widget to reflect icon order changes."""
        # Get the horizontal container
        try:
            container = self.query_one(Horizontal)
        except Exception:
            return

        # Find the FileLink position before removing icons
        try:
            file_link = self.query_one(FileLink)
        except Exception:
            return

        # Remove all existing icon statics and await removal
        icons_to_remove = list(self.query(".status-icon"))
        for static in icons_to_remove:
            await static.remove()

        # Now recalculate FileLink index after removals
        try:
            file_link_index = list(container.children).index(file_link)
        except Exception:
            return

        # Insert before icons
        before_icons = self._sort_icons(self._icons, "before")
        for i, icon_config in enumerate(before_icons):
            if icon_config.visible:
                icon_static = self._create_icon_static(icon_config)
                # Calculate position: after toggle (if shown), before file_link
                insert_pos = (1 if self._show_toggle else 0) + i
                container.mount(icon_static, before=insert_pos)

        # Insert after icons (need to recalculate file_link_index after before icons)
        file_link_index = list(container.children).index(file_link)
        after_icons = self._sort_icons(self._icons, "after")
        for icon_config in after_icons:
            if icon_config.visible:
                icon_static = self._create_icon_static(icon_config)
                # Insert right after FileLink
                container.mount(icon_static, after=file_link_index)

    def get_icon(self, name: str) -> dict | None:
        """Get a copy of an icon's configuration.

        Parameters
        ----------
        name : str
            The name of the icon to retrieve.

        Returns
        -------
        dict | None
            A dictionary copy of the icon configuration, or None if not found.
        """
        icon_config = self._get_icon_config(name)
        if icon_config is None:
            return None
        return asdict(icon_config)

    def _get_icon_config(self, name: str) -> IconConfig | None:
        """Get the IconConfig object for a given name (internal use)."""
        for icon_config in self._icons:
            if icon_config.name == name:
                return icon_config
        return None

    def set_toggle_tooltip(self, tooltip: str | None) -> None:
        """Update the toggle button tooltip.

        Parameters
        ----------
        tooltip : str | None
            New tooltip text, or None to remove tooltip.
        """
        self._toggle_tooltip = tooltip
        try:
            toggle_static = self.query_one("#toggle", Static)
            toggle_static.tooltip = self._enhance_tooltip(tooltip, "toggle")
        except Exception:
            pass

    def set_remove_tooltip(self, tooltip: str | None) -> None:
        """Update the remove button tooltip.

        Parameters
        ----------
        tooltip : str | None
            New tooltip text, or None to remove tooltip.
        """
        self._remove_tooltip = tooltip
        try:
            remove_static = self.query_one("#remove", Static)
            remove_static.tooltip = self._enhance_tooltip(tooltip, "remove")
        except Exception:
            pass

    def set_link_tooltip(self, tooltip: str | None) -> None:
        """Update the filename/link tooltip.

        Parameters
        ----------
        tooltip : str | None
            New tooltip text, or None to remove tooltip.
        """
        self._link_tooltip = tooltip
        try:
            file_link = self.query_one(FileLink)
            file_link.tooltip = self._enhance_tooltip(tooltip, "open_file")
        except Exception:
            pass

    @on(events.Click, "#toggle")
    def _on_toggle_clicked(self, event: events.Click) -> None:
        """Handle toggle click (if shown)."""
        if not self._show_toggle:
            return
        event.stop()  # Prevent bubbling
        self._is_toggled = not self._is_toggled

        # Update static content
        toggle_static = self.query_one("#toggle", Static)
        toggle_static.update("☑" if self._is_toggled else "☐")

        # Update disabled state
        self._update_disabled_state()

        # Post message
        self.post_message(self.Toggled(self._path, self._is_toggled))

    @on(events.Click, ".status-icon")
    def _on_icon_clicked(self, event: events.Click) -> None:
        """Handle status icon click (if clickable)."""
        event.stop()  # Prevent bubbling

        # Extract icon name from ID
        target = event.control
        if not isinstance(target, Static):
            return

        icon_id = target.id
        if not icon_id or not icon_id.startswith("icon-"):
            return

        icon_name = icon_id[5:]  # Remove "icon-" prefix
        icon_config = self._get_icon_config(icon_name)

        if icon_config and icon_config.clickable:
            # Post message - it will automatically have self (ToggleableFileLink) as the sender
            self.post_message(self.IconClicked(self._path, icon_name, icon_config.icon))

    @on(events.Click, "#remove")
    def _on_remove_clicked(self, event: events.Click) -> None:
        """Handle remove click (if shown)."""
        if not self._show_remove:
            return
        event.stop()  # Prevent bubbling
        self.post_message(self.Removed(self._path))

    @on(FileLink.Clicked)
    def _on_file_clicked(self, event: FileLink.Clicked) -> None:
        """Handle file link click - prevent if disabled."""
        if self._disable_on_untoggle and not self._is_toggled:
            event.stop()
        # Otherwise let it bubble up

    # ------------------------------------------------------------------ #
    # Keyboard handling
    # ------------------------------------------------------------------ #
    def action_open_file(self) -> None:
        """Open file via keyboard - delegate to child FileLink."""
        file_link = self.query_one(FileLink)
        file_link.action_open_file()

    def action_toggle(self) -> None:
        """Toggle via keyboard - reuse click logic."""
        if not self._show_toggle:
            return
        self._is_toggled = not self._is_toggled

        # Update static content
        toggle_static = self.query_one("#toggle", Static)
        toggle_static.update("☑" if self._is_toggled else "☐")

        # Update disabled state
        self._update_disabled_state()

        # Post message
        self.post_message(self.Toggled(self._path, self._is_toggled))

    def action_remove(self) -> None:
        """Remove via keyboard."""
        if not self._show_remove:
            return
        self.post_message(self.Removed(self._path))

    def action_icon_1(self) -> None:
        """Activate first clickable icon via keyboard."""
        self._activate_icon_by_index(0)

    def action_icon_2(self) -> None:
        """Activate second clickable icon via keyboard."""
        self._activate_icon_by_index(1)

    def action_icon_3(self) -> None:
        """Activate third clickable icon via keyboard."""
        self._activate_icon_by_index(2)

    def action_icon_4(self) -> None:
        """Activate fourth clickable icon via keyboard."""
        self._activate_icon_by_index(3)

    def action_icon_5(self) -> None:
        """Activate fifth clickable icon via keyboard."""
        self._activate_icon_by_index(4)

    def action_icon_6(self) -> None:
        """Activate sixth clickable icon via keyboard."""
        self._activate_icon_by_index(5)

    def action_icon_7(self) -> None:
        """Activate seventh clickable icon via keyboard."""
        self._activate_icon_by_index(6)

    def action_icon_8(self) -> None:
        """Activate eighth clickable icon via keyboard."""
        self._activate_icon_by_index(7)

    def action_icon_9(self) -> None:
        """Activate ninth clickable icon via keyboard."""
        self._activate_icon_by_index(8)

    def _activate_icon_by_index(self, index: int) -> None:
        """Helper to activate Nth clickable icon."""
        clickable_icons = [ic for ic in self._icons if ic.clickable and ic.visible]
        if 0 <= index < len(clickable_icons):
            icon_config = clickable_icons[index]
            self.post_message(self.IconClicked(self._path, icon_config.name, icon_config.icon))

    @property
    def is_toggled(self) -> bool:
        """Get the current toggle state."""
        return self._is_toggled

    @property
    def path(self) -> Path:
        """Get the file path."""
        return self._path

    @property
    def icons(self) -> list[dict]:
        """Get a list of all icon configurations (as dicts)."""
        return [asdict(ic) for ic in self._icons]

    @property
    def file_link(self) -> FileLink:
        """Get the internal FileLink widget."""
        return self.query_one(FileLink)

=-=-=-=-=-=-=-= End File: 'toggleable_file_link.py' =-=-=-=-=-=-=-=