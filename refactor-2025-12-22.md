# textual-filelink Final Architecture

## Design Principles

1. **Single Responsibility** - Each widget has one clear purpose
2. **Composition over Inheritance** - Build complex widgets from simple ones
3. **Display Only** - Widgets display state and emit events
   - **Exception**: FileLink executes commands to open files
4. **Explicit Over Implicit** - Clear, obvious APIs
5. **Fail Fast** - Catch errors at initialization, not runtime
6. **Breaking Changes Welcome** - Clean slate for better design (pre-1.0)

---

## Core Classes

### 1. FileLink (Base Widget)

**Purpose**: Clickable filename that opens a file in an editor

**API**:
```python
FileLink(
    path: Path | str,
    display_name: str | None = None,  # What's shown (defaults to path.name)
    *,
    line: int | None = None,
    column: int | None = None,
    command_builder: Callable | None = None,
    tooltip: str | None = None,
    id: str | None = None,
    classes: str | None = None,
)
```

**Properties**:
- `path: Path` - The actual file path
- `display_name: str` - What's shown to the user
- `line: int | None`
- `column: int | None`

**Methods**:
```python
def open_file(self) -> None
    """Execute the command to open the file in an editor."""
```

**Messages**:
- `FileLink.Clicked(path, line, column)`

**Keyboard**:
- `Enter` or `o` - Open file

**Example**:
```python
# Show "README" but open /path/to/README.md
FileLink(
    path="/path/to/README.md",
    display_name="README",
    tooltip="Project documentation",
    line=42
)
```

---

### 2. Icon (Data Class)

**Purpose**: Configuration for a single icon

**API**:
```python
@dataclass
class Icon:
    """Configuration for an icon in FileLinkWithIcons."""
    
    name: str                      # REQUIRED: Unique identifier
    icon: str                      # REQUIRED: Unicode character
    tooltip: str | None = None     # Optional tooltip
    clickable: bool = False        # Posts IconClicked events?
    key: str | None = None         # Keyboard shortcut (e.g., "1", "s")
    visible: bool = True           # Initially visible?
```

**Validation**:
- Icon names must be unique within a widget (checked at init)
- Icon keys must not conflict with widget bindings (checked at init)
- Icon keys must be unique among icons (checked at init)
- No auto-naming - name is required

**Example**:
```python
Icon(name="status", icon="âœ…", tooltip="Passed")
Icon(name="settings", icon="âš™ï¸", clickable=True, key="s")
Icon(name="warning", icon="âš ï¸", visible=False)  # Hidden initially

# Error cases (fail fast)
Icon(icon="âœ…")  # âœ— Error: missing required argument 'name'
[Icon(name="x", ...), Icon(name="x", ...)]  # âœ— Error: Duplicate name 'x'
Icon(name="play", icon="â–¶ï¸", key="o")  # âœ— Error: key 'o' conflicts with FileLink.open
```

---

### 3. FileLinkWithIcons (Composite Widget)

**Purpose**: FileLink with customizable icons before/after

**API**:
```python
FileLinkWithIcons(
    path: Path | str,
    display_name: str | None = None,
    *,
    icons_before: list[Icon] | None = None,  # Icons before filename
    icons_after: list[Icon] | None = None,   # Icons after filename
    line: int | None = None,
    column: int | None = None,
    command_builder: Callable | None = None,
    tooltip: str | None = None,
    id: str | None = None,
    classes: str | None = None,
)
```

**Layout**:
```
[icon1] [icon2] ... FileLink ... [icon3] [icon4]
 â””â”€ icons_before â”€â”˜             â””â”€ icons_after â”€â”€â”˜
```

**Order**: Determined by list position (first in list = leftmost)

**Properties**:
- `path: Path`
- `display_name: str`
- All FileLink properties

**Methods**:
```python
def update_icon(self, name: str, **kwargs) -> None
    """Update icon properties. Raises KeyError if name not found."""

def set_icon_visible(self, name: str, visible: bool) -> None
    """Show/hide icon. Raises KeyError if name not found."""

def get_icon(self, name: str) -> Icon | None
    """Get icon by name. Returns None if not found."""
```

**Messages**:
- `FileLink.Clicked(path, line, column)` - Inherited
- `FileLinkWithIcons.IconClicked(path, icon_name, icon_char)` - When clickable icon clicked

**Keyboard**:
- `Enter` or `o` - Open file (inherited)
- Custom keys from `Icon.key` - Trigger IconClicked

**Example**:
```python
FileLinkWithIcons(
    path="script.py",
    display_name="Validation Script",
    icons_before=[
        Icon(name="type", icon="ðŸ“„", tooltip="Python file"),
        Icon(name="status", icon="âœ…", tooltip="Validated", clickable=True, key="1"),
    ],
    icons_after=[
        Icon(name="lock", icon="ðŸ”’", tooltip="Read-only"),
    ],
    tooltip="Click to edit script"
)
# Display: ðŸ“„ âœ… Validation Script ðŸ”’
```

---

### 4. CommandLink (Specialized Widget)

**Purpose**: Command orchestration with play/stop, status, and settings

**API**:
```python
CommandLink(
    name: str,                          # Command display name
    *,
    output_path: Path | str | None = None,  # Optional output file
    status_icon: str = "âš«",            # Initial status icon
    status_tooltip: str | None = None,
    running: bool = False,              # Start in running state?
    show_settings: bool = True,         # Show âš™ï¸ button
    command_builder: Callable | None = None,  # For opening output_path
    id: str | None = None,              # Widget ID (auto-sanitized from name if None)
    classes: str | None = None,
)
```

**Fixed Layout** (order never changes):
```
[status/spinner] [â–¶ï¸/â¹ï¸] name [âš™ï¸?]
```

Components:
- **Status/Spinner**: Status icon OR animated spinner (when running)
- **â–¶ï¸/â¹ï¸**: Play button (stopped) or Stop button (running) - always shown
- **Name**: Command name (clickable if output_path set, else Static)
- **âš™ï¸**: Optional settings button

**Properties**:
- `name: str` - Command display name
- `output_path: Path | None` - Output file path (if any)
- `is_running: bool` - Current running state
- `status_icon: str` - Current status icon
- `status_tooltip: str | None` - Current status tooltip

**Methods**:
```python
def set_status(
    self,
    icon: str | None = None,
    running: bool | None = None,
    tooltip: str | None = None,
) -> None:
    """Update command status display.
    
    Parameters
    ----------
    icon : str | None
        Status icon. Required if running=False.
    running : bool | None
        Update running state. If True, shows spinner + stop button.
        If False, shows icon + play button.
    tooltip : str | None
        Tooltip for status icon/spinner.
    
    Raises
    ------
    ValueError
        If running=False and icon is None.
    
    Examples
    --------
    >>> cmd.set_status(running=True, tooltip="Running tests...")
    >>> cmd.set_status(icon="âœ…", running=False, tooltip="All tests passed")
    >>> cmd.set_status(icon="âŒ", tooltip="3 tests failed")  # Update icon only
    """

def set_output_path(self, path: Path | None, tooltip: str | None = None) -> None
    """Update output file path and optional tooltip."""

def set_settings_tooltip(self, tooltip: str) -> None
    """Update settings button tooltip (if show_settings=True)."""
```

**Messages**:
- `CommandLink.PlayClicked(name, output_path)`
- `CommandLink.StopClicked(name, output_path)`
- `CommandLink.SettingsClicked(name, output_path)`
- `CommandLink.OutputClicked(output_path)` - If output_path set and name clicked

**Keyboard**:
- `Enter` or `o` - Open output file (if output_path set)
- `Space` or `p` - Toggle play/stop
- `s` - Settings (if show_settings=True)

**Widget ID**:
- Auto-generated from name if `id=None`: `CommandLink("Run Tests")` â†’ `id="run-tests"`
- Sanitization: lowercase, spacesâ†’hyphens, keep only alphanumeric/hyphens/underscores

**Example**:
```python
# Basic command
cmd = CommandLink(
    "Run Tests",
    status_icon="âš«",
    status_tooltip="Not run yet",
)
# Display: âš« â–¶ï¸ Run Tests âš™ï¸

# Start command
cmd.set_status(running=True, tooltip="Running tests...")
# Display: â § â¹ï¸ Run Tests âš™ï¸ (spinner animates)

# Complete successfully
cmd.set_status(icon="âœ…", running=False, tooltip="All tests passed")
cmd.set_output_path(Path("test_results.log"))
# Display: âœ… â–¶ï¸ Run Tests âš™ï¸ (name now clickable)

# Complete with failure
cmd.set_status(icon="âŒ", running=False, tooltip="3 tests failed")
# Display: âŒ â–¶ï¸ Run Tests âš™ï¸
```

---

### 5. FileLinkList (Container Widget)

**Purpose**: Manage a list of FileLinks/CommandLinks with optional uniform controls

**API**:
```python
FileLinkList(
    *,
    show_toggles: bool = False,    # Add â˜‘/â˜ to items that don't have them
    show_remove: bool = False,     # Add Ã— to items that don't have them
    id: str | None = None,
    classes: str | None = None,
)
```

**Control Behavior**:
- For `FileLink` and `FileLinkWithIcons`: Wraps with toggle/remove controls
- For `CommandLink`: Always wraps with toggle/remove (CommandLink has no built-in controls)

**Properties**:
- `items: list[Widget]` - All child widgets
- `selected_items: list[Widget]` - Items with toggles checked
- `item_count: int` - Number of items

**Methods**:
```python
def add_item(self, item: FileLink | FileLinkWithIcons | CommandLink) -> None
    """Add item to list. Wraps with controls if needed."""

def remove_item(self, item: Widget) -> None
    """Remove item from list."""

def clear_items(self) -> None
    """Remove all items."""

def toggle_all(self, state: bool = True) -> None
    """Toggle all items on or off."""

def remove_selected(self) -> None
    """Remove all items that are toggled."""

def get_selected_items(self) -> list[Widget]
    """Get list of toggled items."""

def __iter__(self) -> Iterator[Widget]
def __len__(self) -> int
```

**Messages**:
- `FileLinkList.ItemToggled(item, is_toggled)` - When any item toggled
- `FileLinkList.ItemRemoved(item)` - When any item removed
- Plus all messages from child items (bubbled up)

**Example**:
```python
# File list with toggles
file_list = FileLinkList(show_toggles=True, show_remove=True)
file_list.add_item(FileLink("file1.py"))
file_list.add_item(FileLink("file2.py"))
# Each item displays: â˜ file1.py Ã—

# Get selected files
selected = file_list.get_selected_items()

# Batch remove
file_list.remove_selected()

# Mixed list (wraps CommandLink uniformly)
mixed_list = FileLinkList(show_toggles=True, show_remove=True)
mixed_list.add_item(FileLink("README.md"))  # Wrapped: â˜ README.md Ã—
mixed_list.add_item(CommandLink("Tests"))    # Wrapped: â˜ âš« â–¶ï¸ Tests âš™ï¸ Ã—
mixed_list.add_item(FileLink("main.py"))    # Wrapped: â˜ main.py Ã—
```

---

## Implementation Details

### Spinner Animation (CommandLink)

```python
SPINNER_FRAMES = ["â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "]

def _start_spinner(self):
    self._spinner_frame = 0
    self._spinner_timer = self.set_interval(0.1, self._animate_spinner)
    self._update_status_display()

def _stop_spinner(self):
    if self._spinner_timer:
        self._spinner_timer.stop()
        self._spinner_timer = None

def _animate_spinner(self):
    self._spinner_frame = (self._spinner_frame + 1) % len(self.SPINNER_FRAMES)
    # Update status Static widget
    self.query_one("#status").update(self.SPINNER_FRAMES[self._spinner_frame])
```

### Icon Validation

```python
def _validate_icons(icons_before: list[Icon], icons_after: list[Icon], widget_bindings: list[Binding]):
    """Validate icon configuration. Raises ValueError on errors."""
    
    all_icons = (icons_before or []) + (icons_after or [])
    
    # Check for duplicate names
    seen_names = set()
    for icon in all_icons:
        if icon.name in seen_names:
            raise ValueError(f"Duplicate icon name: '{icon.name}'")
        seen_names.add(icon.name)
    
    # Check for key conflicts with widget bindings
    widget_keys = {binding.key for binding in widget_bindings}
    icon_keys = {icon.key for icon in all_icons if icon.key}
    
    conflicts = icon_keys & widget_keys
    if conflicts:
        raise ValueError(
            f"Icon keys conflict with widget bindings: {sorted(conflicts)}"
        )
    
    # Check for duplicate keys among icons
    seen_keys = set()
    for icon in all_icons:
        if icon.key:
            if icon.key in seen_keys:
                raise ValueError(f"Duplicate icon key: '{icon.key}'")
            seen_keys.add(icon.key)
```

### ID Sanitization (CommandLink)

```python
@staticmethod
def sanitize_id(name: str) -> str:
    """Convert command name to valid widget ID.
    
    Examples
    --------
    >>> CommandLink.sanitize_id("Run Tests")
    'run-tests'
    >>> CommandLink.sanitize_id("Build Project!")
    'build-project-'
    """
    sanitized = name.lower().replace(" ", "-")
    return "".join(c if c.isalnum() or c in ("-", "_") else "-" for c in sanitized)

# Usage in __init__
def __init__(self, name: str, *, id: str | None = None, ...):
    self._name = name
    widget_id = id if id is not None else self.sanitize_id(name)
    super().__init__(id=widget_id, ...)
```

### FileLinkList Wrapping

```python
def add_item(self, item: FileLink | FileLinkWithIcons | CommandLink):
    """Add item to list, wrapping with controls if needed."""
    
    # All items get wrapped uniformly
    wrapped = FileLinkListItem(
        item,
        show_toggle=self.show_toggles,
        show_remove=self.show_remove,
    )
    self.mount(wrapped)
```

---

## Migration Guide

### ToggleableFileLink â†’ FileLinkList + FileLinkWithIcons

**Before**:
```python
yield ToggleableFileLink(
    "file.py",
    initial_toggle=True,
    show_toggle=True,
    show_remove=True,
    icons=[{"name": "status", "icon": "âœ…", "position": "before"}]
)
```

**After**:
```python
file_list = FileLinkList(show_toggles=True, show_remove=True)

link = FileLinkWithIcons(
    "file.py",
    icons_before=[Icon(name="status", icon="âœ…")]
)
file_list.add_item(link)

# Set initial toggle state
link.set_toggle(True)  # Or: file_list wraps and manages toggle
```

### Current CommandLink â†’ New CommandLink

**Before**:
```python
cmd = CommandLink(
    "Tests",
    output_path="results.log",
    initial_status_icon="âš«",
    initial_status_tooltip="Not run",
)
cmd.set_status(running=True, tooltip="Running...")
cmd.set_status(icon="âœ…", running=False, tooltip="Passed")
```

**After**:
```python
cmd = CommandLink(
    "Tests",
    output_path="results.log",
    status_icon="âš«",
    status_tooltip="Not run",
)
cmd.set_status(running=True, tooltip="Running...")
cmd.set_status(icon="âœ…", running=False, tooltip="Passed")
```

Main changes:
- `initial_status_icon` â†’ `status_icon`
- `initial_status_tooltip` â†’ `status_tooltip`
- `set_status()` now handles both running and icon in one call

---

## Summary of Key Decisions

1. âœ… **FileLink opens files** (exception to display-only rule)
2. âœ… **CommandLink builds its own layout** (doesn't use FileLinkWithIcons)
3. âœ… **CommandLink has NO toggle/remove** (FileLinkList adds them uniformly)
4. âœ… **Icon.name is required** (no auto-naming)
5. âœ… **Fail fast on duplicate names/keys**
6. âœ… **Combined set_status() method** (handles running + icon in one call)
7. âœ… **Widget ID sanitization** (CommandLink auto-generates from name)
8. âœ… **No icon name sanitization** (keep as provided for clarity)
9. âœ… **Keep FileLinkWithIcons** (useful for files with status/metadata)

---

## Next Steps

1. Implement `Icon` dataclass with validation
2. Update `FileLink` with `display_name` parameter
3. Create `FileLinkWithIcons` from scratch
4. Redesign `CommandLink` with fixed layout
5. Implement `FileLinkList` container
6. Write comprehensive tests
7. Update README with new API and examples

Ready to start implementation?