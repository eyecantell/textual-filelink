# textual-filelink Final Architecture

## Design Principles

1. **Single Responsibility** - Each widget has one clear purpose
2. **Composition over Inheritance** - Build complex widgets from simple ones
3. **Display Only** - Widgets display state and emit events
   - **Exception**: FileLink executes commands to open files
4. **Explicit Over Implicit** - Clear, obvious APIs
5. **Fail Fast** - Catch errors at initialization, not runtime
6. **Breaking Changes Welcome** - Clean slate for better design (pre-1.0)
7. **Stateful UI Controllers** - CommandLink is a stateful UI controller (manages animation, state)

---

## Core Amendments (December 2024)

These amendments refine the original design:

1. **Keyboard bindings via `_get_bindings()` override** - Instance-level bindings without class mutation
2. **FileLink.Clicked â†’ FileLink.Opened** - Better semantics, unified behavior
3. **Icon clicks unified** - Mouse and keyboard follow same path, emit IconClicked
4. **ID responsibilities** - FileLink: no auto-gen; CommandLink: auto-gen from name
5. **CommandLink is stateful** - Owns spinner, timers, running state (but not command execution)
6. **set_status(running: bool | None = None)** - Explicit control, no implicit changes
7. **FileLinkList requires IDs** - All items must have explicit IDs (fail fast on duplicates)
8. **add_item(toggled=False)** - Set initial state directly (no wrapper exposure)
9. **Click behavior** - Play/stop controls running; name always opens output
10. **Icon.name preserved** - Not renamed to `id` (avoids confusion)
11. **sanitize_id() utility** - Centralized ID sanitization (reusable across widgets)
12. **is_item_toggled()** - Boolean getter follows Python convention (was: get_item_toggle)

---

## Core Classes

### 1. FileLink (Base Widget)

**Purpose**: Clickable filename that opens a file in an editor

**API**:
```python
class FileLink(Static, can_focus=True):
    """Clickable file link."""
    
    # Default keyboard shortcuts (can be overridden per instance)
    DEFAULT_OPEN_KEYS = ["enter", "o"]
    
    def __init__(
        self,
        path: Path | str,
        display_name: str | None = None,  # What's shown (defaults to path.name)
        *,
        line: int | None = None,
        column: int | None = None,
        command_builder: Callable | None = None,
        open_keys: list[str] | None = None,  # If None, uses DEFAULT_OPEN_KEYS
        tooltip: str | None = None,
        id: str | None = None,
        classes: str | None = None,       # CSS classes for styling
    ):
```

**Properties**:
- `path: Path` - The actual file path
- `display_name: str` - What's shown to the user
- `line: int | None`
- `column: int | None`

**Methods**:
```python
def open_file(self) -> None
    """Execute the command to open the file and emit Opened event."""
```

**Messages**:
- `FileLink.Opened(path, line, column)` - Emitted after file opens (was: Clicked)

**Keyboard**:
- Default: `Enter` or `o` to open file
- Customizable via `open_keys` parameter or `DEFAULT_OPEN_KEYS` class attribute

**Example**:
```python
# Default keys (enter/o)
FileLink(path="/path/to/README.md", display_name="README")

# Custom keys for instance
FileLink(path="file.py", open_keys=["f2", "ctrl+o"])

# Override defaults for all instances
FileLink.DEFAULT_OPEN_KEYS = ["f2"]
FileLink(path="file.py")  # Now uses F2 by default

# CSS styling
FileLink(path="file.py", classes="important urgent")
```

---

### 2. Icon (Data Class)

**Purpose**: Configuration for a single icon

**API**:
```python
@dataclass
class Icon:
    """Configuration for an icon in FileLinkWithIcons."""
    
    name: str                      # REQUIRED: Unique identifier
    icon: str                      # REQUIRED: Unicode character
    tooltip: str | None = None     # Optional tooltip
    clickable: bool = False        # Posts IconClicked events?
    key: str | None = None         # Keyboard shortcut (e.g., "1", "s")
    visible: bool = True           # Initially visible?
```

**Validation**:
- Icon names must be unique within a widget (checked at init)
- Icon keys must not conflict with widget bindings (checked at init)
- Icon keys must be unique among icons (checked at init)
- No auto-naming - name is required

**Example**:
```python
Icon(name="status", icon="âœ…", tooltip="Passed")
Icon(name="settings", icon="âš™ï¸", clickable=True, key="s")
Icon(name="warning", icon="âš ï¸", visible=False)  # Hidden initially

# Error cases (fail fast)
Icon(icon="âœ…")  # âœ— Error: missing required argument 'name'
[Icon(name="x", ...), Icon(name="x", ...)]  # âœ— Error: Duplicate name 'x'
Icon(name="play", icon="â–¶ï¸", key="o")  # âœ— Error: key 'o' conflicts with FileLink.open
```

---

### 3. FileLinkWithIcons (Composite Widget)

**Purpose**: FileLink with customizable icons before/after

**API**:
```python
FileLinkWithIcons(
    path: Path | str,
    display_name: str | None = None,
    *,
    icons_before: list[Icon] | None = None,  # Icons before filename
    icons_after: list[Icon] | None = None,   # Icons after filename
    line: int | None = None,
    column: int | None = None,
    command_builder: Callable | None = None,
    open_keys: list[str] | None = None,      # Pass through to FileLink
    tooltip: str | None = None,
    id: str | None = None,
    classes: str | None = None,
)
```

**Layout**:
```
[icon1] [icon2] ... FileLink ... [icon3] [icon4]
 â””â”€ icons_before â”€â”˜             â””â”€ icons_after â”€â”€â”˜
```

**Order**: Determined by list position (first in list = leftmost)

**Properties**:
- `path: Path`
- `display_name: str`
- All FileLink properties

**Methods**:
```python
def update_icon(self, name: str, **kwargs) -> None
    """Update icon properties.
    
    Raises
    ------
    KeyError
        If no icon with the given name exists.
    """

def set_icon_visible(self, name: str, visible: bool) -> None
    """Show/hide icon.
    
    Raises
    ------
    KeyError
        If no icon with the given name exists.
    """

def get_icon(self, name: str) -> Icon
    """Get icon by name.
    
    Raises
    ------
    KeyError
        If no icon with the given name exists.
    """
```

**Messages**:
- `FileLink.Opened(path, line, column)` - Inherited (emitted after file opens)
- `FileLinkWithIcons.IconClicked(path, icon_name, icon_char)` - When clickable icon clicked

**Keyboard**:
- `Enter` or `o` - Open file (inherited, customizable via open_keys)
- Custom keys from `Icon.key` - Trigger IconClicked

**Example**:
```python
FileLinkWithIcons(
    path="script.py",
    display_name="Validation Script",
    icons_before=[
        Icon(name="type", icon="ðŸ“„", tooltip="Python file"),
        Icon(name="status", icon="âœ…", tooltip="Validated", clickable=True, key="1"),
    ],
    icons_after=[
        Icon(name="lock", icon="ðŸ”’", tooltip="Read-only"),
    ],
    tooltip="Click to edit script"
)
# Display: ðŸ“„ âœ… Validation Script ðŸ”’
```

---

### 4. CommandLink (Specialized Widget)

**Purpose**: Command orchestration with play/stop, status, and settings

**API**:
```python
class CommandLink(Widget):
    """Command control widget."""
    
    # Default keyboard shortcuts (can be overridden per instance or class)
    DEFAULT_OPEN_KEYS = ["enter", "o"]
    DEFAULT_PLAY_STOP_KEYS = ["space", "p"]
    DEFAULT_SETTINGS_KEYS = ["s"]
    
    def __init__(
        self,
        name: str,                          # Command display name
        *,
        output_path: Path | str | None = None,  # Optional output file
        status_icon: str = "âš«",            # Initial status icon
        status_tooltip: str | None = None,
        running: bool = False,              # Start in running state?
        show_settings: bool = True,         # Show âš™ï¸ button
        command_builder: Callable | None = None,  # For opening output_path
        open_keys: list[str] | None = None,       # If None, uses DEFAULT_OPEN_KEYS
        play_stop_keys: list[str] | None = None,  # If None, uses DEFAULT_PLAY_STOP_KEYS
        settings_keys: list[str] | None = None,   # If None, uses DEFAULT_SETTINGS_KEYS
        id: str | None = None,              # Widget ID (auto-sanitized from name if None)
        classes: str | None = None,         # CSS classes for styling
    ):
```

**Fixed Layout** (order never changes):
```
[status/spinner] [â–¶ï¸/â¹ï¸] name [âš™ï¸?]
```

Components:
- **Status/Spinner**: Status icon OR animated spinner (when running)
- **â–¶ï¸/â¹ï¸**: Play button (stopped) or Stop button (running) - always shown
- **Name**: Command name (clickable if output_path set, else Static)
- **âš™ï¸**: Optional settings button

**Properties**:
- `name: str` - Command display name
- `output_path: Path | None` - Output file path (if any)
- `is_running: bool` - Current running state
- `status_icon: str` - Current status icon
- `status_tooltip: str | None` - Current status tooltip

**Methods**:
```python
def set_status(
    self,
    *,
    icon: str | None = None,
    running: bool | None = None,  # None = no change to running state
    tooltip: str | None = None,
) -> None:
    """Update command status display.
    
    Parameters
    ----------
    icon : str | None
        Status icon. If provided, stops spinner and shows icon.
    running : bool | None
        Update running state. If True, shows spinner + stop button.
        If False, shows icon + play button. If None, maintains current state.
    tooltip : str | None
        Tooltip for status icon/spinner.
    
    Examples
    --------
    >>> cmd.set_status(running=True, tooltip="Running tests...")  # Start
    >>> cmd.set_status(icon="âœ…", running=False, tooltip="Passed")  # Stop with status
    >>> cmd.set_status(tooltip="Test 5 of 10...")  # Update tooltip only
    >>> cmd.set_status(icon="âŒ", tooltip="Failed")  # Update icon (running unchanged)
    """

def set_output_path(self, path: Path | None, tooltip: str | None = None) -> None
    """Update output file path and optional tooltip."""

def set_settings_tooltip(self, tooltip: str) -> None
    """Update settings button tooltip (if show_settings=True)."""
```

**Messages**:
- `CommandLink.PlayClicked(name, output_path)`
- `CommandLink.StopClicked(name, output_path)`
- `CommandLink.SettingsClicked(name, output_path)`
- `CommandLink.OutputClicked(output_path)` - If output_path set and name clicked

**Keyboard**:
- Default: `Enter`/`o` (open output), `Space`/`p` (play/stop), `s` (settings)
- Customizable via parameters or class attributes

**Widget ID**:
- Auto-generated from name if `id=None`: `CommandLink("Run Tests")` â†’ `id="run-tests"`
- Uses `sanitize_id()` utility: lowercase, spacesâ†’hyphens, alphanumeric/hyphens/underscores only

**Example**:
```python
# Basic command
cmd = CommandLink(
    "Run Tests",
    status_icon="âš«",
    status_tooltip="Not run yet",
)
# Display: âš« â–¶ï¸ Run Tests âš™ï¸

# Start command
cmd.set_status(running=True, tooltip="Running tests...")
# Display: â § â¹ï¸ Run Tests âš™ï¸ (spinner animates)

# Complete successfully
cmd.set_status(icon="âœ…", running=False, tooltip="All tests passed")
cmd.set_output_path(Path("test_results.log"))
# Display: âœ… â–¶ï¸ Run Tests âš™ï¸ (name now clickable)

# Complete with failure
cmd.set_status(icon="âŒ", running=False, tooltip="3 tests failed")
# Display: âŒ â–¶ï¸ Run Tests âš™ï¸

# Custom keyboard shortcuts
cmd = CommandLink(
    "Tests",
    play_stop_keys=["f5"],      # F5 to run/stop
    settings_keys=["f6"],       # F6 for settings
    open_keys=["f7"],           # F7 to open output
)

# Override defaults for all CommandLinks
CommandLink.DEFAULT_PLAY_STOP_KEYS = ["f5"]
cmd = CommandLink("Tests")  # Now uses F5 for play/stop
```

---

### 5. FileLinkList (Container Widget)

**Purpose**: Scrollable container for FileLinks/CommandLinks with optional uniform controls

**API**:
```python
class FileLinkList(VerticalScroll):
    """Scrollable file/command list."""
    
    def __init__(
        self,
        *,
        direction: Literal["vertical", "horizontal"] = "vertical",  # Layout direction
        show_toggles: bool = False,    # Add â˜‘/â˜ to all items
        show_remove: bool = False,     # Add Ã— to all items
        id: str | None = None,
        classes: str | None = None,    # CSS classes for styling
    ):
```

**Control Behavior**:
- Wraps **all** item types (FileLink, FileLinkWithIcons, CommandLink) uniformly
- No special casing - same treatment for all widgets

**Scrolling**:
- Automatically scrollable when content exceeds container height (vertical)
- Future: horizontal scrolling support (requires custom implementation)

**Properties**:
- `items: list[Widget]` - All child widgets
- `selected_items: list[Widget]` - Items with toggles checked
- `item_count: int` - Number of items

**Methods**:
```python
def add_item(self, item: FileLink | FileLinkWithIcons | CommandLink) -> None
    """Add item to list. Wraps with controls if needed."""

def remove_item(self, item: Widget) -> None
    """Remove item from list."""

def clear_items(self) -> None
    """Remove all items."""

def toggle_all(self, state: bool = True) -> None
    """Toggle all items on or off."""

def remove_selected(self) -> None
    """Remove all items that are toggled."""

def get_selected_items(self) -> list[Widget]
    """Get list of toggled items."""

def __iter__(self) -> Iterator[Widget]
def __len__(self) -> int
```

**Messages**:
- `FileLinkList.ItemToggled(item, is_toggled)` - When any item toggled
- `FileLinkList.ItemRemoved(item)` - When any item removed
- Plus all messages from child items (bubbled up)

**Example**:
```python
# Vertical scrollable file list with toggles
file_list = FileLinkList(
    direction="vertical",  # Default
    show_toggles=True,
    show_remove=True
)

# Add items with initial toggle states (IDs required)
file_list.add_item(FileLink("file1.py", id="file1"))  # Not toggled
file_list.add_item(FileLink("file2.py", id="file2"), toggled=True)  # Initially toggled

# Update toggle state later
file_list.set_item_toggle(id="file1", toggled=True)  # Via ID
file_list.set_item_toggle_by_index(0, False)  # Via index

# Query toggle state
if file_list.is_item_toggled(id="file2"):
    print("File 2 is selected")

# Batch operations
for path in Path(".").glob("*.py"):
    file_list.add_item(
        FileLink(path, id=sanitize_id(str(path))),  # Use sanitize_id utility
        toggled=(path.stem == "main")  # Toggle main.py
    )

# ID validation (fail fast)
file_list.add_item(FileLink("file.py"))  # âœ— ValueError: ID required
file_list.add_item(FileLink("dup.py", id="file1"))  # âœ— ValueError: Duplicate ID

# Get selected files
selected = file_list.get_selected_items()

# Batch remove
file_list.remove_selected()

# Mixed list (wraps CommandLink uniformly)
mixed_list = FileLinkList(show_toggles=True, show_remove=True)
mixed_list.add_item(FileLink("README.md", id="readme"))
mixed_list.add_item(CommandLink("Tests"))  # CommandLink auto-generates ID
mixed_list.add_item(FileLink("main.py", id="main"))

# CSS styling
file_list = FileLinkList(classes="primary-list bordered")
```

---

## Implementation Details

### Utility Functions

**`sanitize_id()`** - Centralized ID sanitization:

```python
# textual_filelink/utils.py
def sanitize_id(name: str) -> str:
    """Convert name to valid widget ID.
    
    Sanitizes for use as Textual widget ID: lowercase, spacesâ†’hyphens,
    path separatorsâ†’hyphens, keep only alphanumeric/hyphens/underscores.
    
    Examples
    --------
    >>> sanitize_id("Run Tests")
    'run-tests'
    >>> sanitize_id("src/main.py")
    'src-main-py'
    >>> sanitize_id("Build Project!")
    'build-project-'
    """
    sanitized = name.lower().replace(" ", "-")
    sanitized = sanitized.replace("/", "-").replace("\\", "-")
    return "".join(c if c.isalnum() or c in ("-", "_") else "-" for c in sanitized)

# Usage in CommandLink
from .utils import sanitize_id

class CommandLink(Widget):
    def __init__(self, name: str, *, id: str | None = None, ...):
        widget_id = id if id is not None else sanitize_id(name)
        super().__init__(id=widget_id, ...)

# User code
from textual_filelink.utils import sanitize_id

file_list.add_item(FileLink(path, id=sanitize_id(str(path))))
```

### Custom Keyboard Bindings

All widgets support custom keyboard shortcuts via instance-level `_bindings` with `_get_bindings()` override:

```python
class FileLink(Static, can_focus=True):
    DEFAULT_OPEN_KEYS = ["enter", "o"]

    # Class-level BINDINGS used as fallback
    BINDINGS = [
        Binding("enter", "open_file", "Open file", show=False),
        Binding("o", "open_file", "Open file", show=False),
    ]

    def __init__(self, path, *, open_keys=None, ...):
        super().__init__(...)
        # Store custom keys if provided
        if open_keys is not None:
            self._custom_bindings = [
                Binding(key, "open_file", "Open file", show=False)
                for key in open_keys
            ]
        else:
            self._custom_bindings = None

    @property
    def _bindings(self) -> list[Binding]:
        """Return instance-specific bindings (Textual checks this)."""
        if self._custom_bindings is not None:
            return self._custom_bindings
        return self.BINDINGS

# Instance override
FileLink("file.py", open_keys=["f2"])  # Uses F2 only

# Class override (affects all instances without custom keys)
FileLink.DEFAULT_OPEN_KEYS = ["f2"]
FileLink("file.py")  # Uses F2 by default
```

**Why instance-level `_bindings`?**
- Avoids mutating class-level `BINDINGS` in `__init__`
- Prevents lifecycle timing issues with multiple instances
- Each instance can have independent key bindings
- Falls back to class-level `BINDINGS` when no custom keys provided

**Alternative: Runtime `bind()` in `on_mount()`**
```python
def on_mount(self) -> None:
    """Set up instance-specific bindings after mount."""
    if self._custom_keys:
        for key in self._custom_keys:
            self.bind(key, "open_file", description="Open file", show=False)
```

### Event Semantics

`FileLink` uses `Opened` event (not `Clicked`) for clarity:

```python
class FileLink:
    class Opened(Message):
        """Posted after file opens successfully."""
        def __init__(self, path: Path, line: int | None, column: int | None):
            ...
    
    def on_click(self, event):
        """Mouse click handler."""
        event.stop()
        self.open_file()  # Single path
    
    def action_open_file(self):
        """Keyboard action handler."""
        self.open_file()  # Same path
    
    def open_file(self):
        """Open file and emit event (single source of truth)."""
        # Execute command
        self._do_open_file()
        # Emit event
        self.post_message(self.Opened(self._path, self._line, self._column))
```

### CSS Classes

The `classes` parameter applies CSS styling:

```python
# Apply CSS classes
FileLink("file.py", classes="important urgent")

# CSS definition
"""
FileLink.important {
    color: yellow;
    text-style: bold;
}
FileLink.urgent {
    background: red;
}
"""

# Dynamic class management
link = FileLink("file.py")
link.add_class("highlighted")
link.remove_class("highlighted")
link.has_class("highlighted")  # False
```

### Spinner Animation (CommandLink)

```python
SPINNER_FRAMES = ["â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "]

def _start_spinner(self):
    self._spinner_frame = 0
    self._spinner_timer = self.set_interval(0.1, self._animate_spinner)
    self._update_status_display()

def _stop_spinner(self):
    if self._spinner_timer:
        self._spinner_timer.stop()
        self._spinner_timer = None

def _animate_spinner(self):
    self._spinner_frame = (self._spinner_frame + 1) % len(self.SPINNER_FRAMES)
    # Update status Static widget
    self.query_one("#status").update(self.SPINNER_FRAMES[self._spinner_frame])
```

### Icon Validation

```python
def _validate_icons(icons_before: list[Icon], icons_after: list[Icon], widget_bindings: list[Binding]):
    """Validate icon configuration. Raises ValueError on errors."""
    
    all_icons = (icons_before or []) + (icons_after or [])
    
    # Check for duplicate names
    seen_names = set()
    for icon in all_icons:
        if icon.name in seen_names:
            raise ValueError(f"Duplicate icon name: '{icon.name}'")
        seen_names.add(icon.name)
    
    # Check for key conflicts with widget bindings
    widget_keys = {binding.key for binding in widget_bindings}
    icon_keys = {icon.key for icon in all_icons if icon.key}
    
    conflicts = icon_keys & widget_keys
    if conflicts:
        raise ValueError(
            f"Icon keys conflict with widget bindings: {sorted(conflicts)}"
        )
    
    # Check for duplicate keys among icons
    seen_keys = set()
    for icon in all_icons:
        if icon.key:
            if icon.key in seen_keys:
                raise ValueError(f"Duplicate icon key: '{icon.key}'")
            seen_keys.add(icon.key)
```

### ID Sanitization (CommandLink)

```python
@staticmethod
def sanitize_id(name: str) -> str:
    """Convert command name to valid widget ID.
    
    Examples
    --------
    >>> CommandLink.sanitize_id("Run Tests")
    'run-tests'
    >>> CommandLink.sanitize_id("Build Project!")
    'build-project-'
    """
    sanitized = name.lower().replace(" ", "-")
    return "".join(c if c.isalnum() or c in ("-", "_") else "-" for c in sanitized)

# Usage in __init__
def __init__(self, name: str, *, id: str | None = None, ...):
    self._name = name
    widget_id = id if id is not None else self.sanitize_id(name)
    super().__init__(id=widget_id, ...)
```

### FileLinkList Implementation

FileLinkList inherits from `VerticalScroll` for automatic scrolling and enforces ID uniqueness:

```python
from textual.containers import VerticalScroll

class FileLinkList(VerticalScroll):
    """Scrollable container for FileLinks/CommandLinks."""
    
    def __init__(
        self,
        *,
        direction: Literal["vertical", "horizontal"] = "vertical",
        show_toggles: bool = False,
        show_remove: bool = False,
        ...
    ):
        if direction == "horizontal":
            raise NotImplementedError(
                "Horizontal direction not yet implemented. "
                "Use direction='vertical' (default)."
            )
        
        super().__init__(...)
        self._show_toggles = show_toggles
        self._show_remove = show_remove
        self._items: list[FileLinkListItem] = []
        self._item_ids: set[str] = set()  # Track IDs for duplicate detection
    
    def add_item(
        self,
        item: FileLink | FileLinkWithIcons | CommandLink,
        *,
        toggled: bool = False,
    ) -> None:
        """Add item to list with initial toggle state.
        
        Raises
        ------
        ValueError
            If item.id is None (all items must have explicit IDs).
            If item.id already exists in the list (duplicate ID).
        """
        # Validate ID exists
        if not item.id:
            # Generate helpful error message
            item_repr = f"FileLink('{item.path}')" if hasattr(item, 'path') else str(item)
            raise ValueError(
                f"Item must have an explicit 'id' for use in FileLinkList. "
                f"Example: {item_repr.replace(')', ", id='unique-id')")}"
            )
        
        # Check for duplicate ID
        if item.id in self._item_ids:
            raise ValueError(
                f"Item with ID '{item.id}' already exists in list. "
                f"Each item must have a unique ID."
            )
        
        # Wrap with controls
        wrapped = FileLinkListItem(
            item,
            show_toggle=self._show_toggles,
            show_remove=self._show_remove,
        )
        wrapped.set_toggle(toggled)  # Set initial state
        
        # Track ID
        self._item_ids.add(item.id)
        
        # Mount and track
        self.mount(wrapped)
        self._items.append(wrapped)
    
    def remove_item(self, *, id: str | None = None, item: Widget | None = None) -> None:
        """Remove item from list.
        
        Parameters
        ----------
        id : str | None
            Widget ID to remove.
        item : Widget | None
            Widget instance to remove.
        
        Notes
        -----
        Exactly one of `id` or `item` must be provided.
        """
        if (id is None) == (item is None):
            raise ValueError("Provide exactly one of: id or item")
        
        # Find by ID
        if id:
            item = self.query_one(f"#{id}")
        
        # Untrack ID
        if item.id and item.id in self._item_ids:
            self._item_ids.remove(item.id)
        
        # Remove from tracking
        for wrapped in self._items:
            if wrapped.item == item:
                self._items.remove(wrapped)
                wrapped.remove()
                return
    
    def set_item_toggle(
        self,
        *,
        id: str | None = None,
        item: Widget | None = None,
        toggled: bool,
    ) -> None:
        """Set toggle state for a specific item.
        
        Parameters
        ----------
        id : str | None
            Widget ID.
        item : Widget | None
            Widget instance.
        toggled : bool
            New toggle state.
        
        Notes
        -----
        Exactly one of `id` or `item` must be provided.
        """
        if (id is None) == (item is None):
            raise ValueError("Provide exactly one of: id or item")
        
        # Find by ID
        if id:
            item = self.query_one(f"#{id}")
        
        # Set toggle
        for wrapped in self._items:
            if wrapped.item == item:
                wrapped.set_toggle(toggled)
                return
        raise ValueError(f"Item not found in list")
    
    def get_item_toggle(self, *, id: str | None = None, item: Widget | None = None) -> bool:
        """Get toggle state for a specific item."""
        if (id is None) == (item is None):
            raise ValueError("Provide exactly one of: id or item")
        
        # Find by ID
        if id:
            item = self.query_one(f"#{id}")
        
        # Get toggle
        for wrapped in self._items:
            if wrapped.item == item:
                return wrapped.is_toggled
        raise ValueError(f"Item not found in list")
    
    def set_item_toggle_by_index(self, index: int, toggled: bool) -> None:
        """Set toggle state by item index."""
        if 0 <= index < len(self._items):
            self._items[index].set_toggle(toggled)
        else:
            raise IndexError(f"Index {index} out of range")
```

**CSS for scrolling**:
```css
FileLinkList {
    height: 100%;
    overflow-y: auto;  /* Vertical scroll */
}
```

---

## Version & Breaking Changes

**Target Version**: 0.4.0

Per [semver](https://semver.org/), versions before 1.0.0 may introduce breaking changes in any release. This refactor takes advantage of that to deliver a cleaner API without backwards compatibility burden.

**Removed in 0.4.0**:
- `ToggleableFileLink` class (replaced by `FileLinkWithIcons` + `FileLinkList`)
- `FileLink.Clicked` message (replaced by `FileLink.Opened`)
- `IconConfig` dataclass (replaced by `Icon`)

**New in 0.4.0**:
- `FileLinkWithIcons` - FileLink with customizable icons
- `FileLinkList` - Container with uniform toggle/remove controls
- `Icon` dataclass with required `name` field
- `sanitize_id()` utility function
- Per-instance keyboard shortcut customization

---

## Migration Guide

### ToggleableFileLink â†’ FileLinkList + FileLinkWithIcons

**Before**:
```python
yield ToggleableFileLink(
    "file.py",
    initial_toggle=True,
    show_toggle=True,
    show_remove=True,
    icons=[{"name": "status", "icon": "âœ…", "position": "before"}]
)
```

**After**:
```python
file_list = FileLinkList(show_toggles=True, show_remove=True)

link = FileLinkWithIcons(
    "file.py",
    icons_before=[Icon(name="status", icon="âœ…")]
)
file_list.add_item(link)

# Set initial toggle state
link.set_toggle(True)  # Or: file_list wraps and manages toggle
```

### Current CommandLink â†’ New CommandLink

**Before**:
```python
cmd = CommandLink(
    "Tests",
    output_path="results.log",
    initial_status_icon="âš«",
    initial_status_tooltip="Not run",
)
cmd.set_status(running=True, tooltip="Running...")
cmd.set_status(icon="âœ…", running=False, tooltip="Passed")
```

**After**:
```python
cmd = CommandLink(
    "Tests",
    output_path="results.log",
    status_icon="âš«",
    status_tooltip="Not run",
)
cmd.set_status(running=True, tooltip="Running...")
cmd.set_status(icon="âœ…", running=False, tooltip="Passed")
```

Main changes:
- `initial_status_icon` â†’ `status_icon`
- `initial_status_tooltip` â†’ `status_tooltip`
- `set_status()` now handles both running and icon in one call

---

## Summary of Key Decisions

1. âœ… **FileLink opens files** (exception to display-only rule)
2. âœ… **CommandLink builds its own layout** (doesn't use FileLinkWithIcons)
3. âœ… **CommandLink has NO toggle/remove** (FileLinkList adds them uniformly)
4. âœ… **Icon.name is required** (no auto-naming)
5. âœ… **Fail fast on duplicate names/keys**
6. âœ… **set_status(running: bool | None = None)** (explicit control, no implicit changes)
7. âœ… **Widget ID sanitization** (CommandLink auto-generates from name)
8. âœ… **No icon name sanitization** (keep as provided for clarity)
9. âœ… **Keep FileLinkWithIcons** (useful for files with status/metadata)
10. âœ… **Custom keyboard shortcuts** (via compose_bindings() and DEFAULT_* class attributes)
11. âœ… **FileLinkList is scrollable** (inherits from VerticalScroll)
12. âœ… **Keep set_icon_visible()** (clearer than update_icon for visibility)
13. âœ… **Uniform wrapping** (FileLinkList treats all widget types the same)
14. âœ… **get_icon() raises KeyError** (fail fast, not None)
15. âœ… **add_item(toggled=False)** (set initial toggle state directly)
16. âœ… **FileLinkList requires IDs** (fail fast on missing or duplicate IDs)
17. âœ… **CSS classes parameter** (for styling all widgets)
18. âœ… **FileLink.Opened event** (was Clicked, unified mouse/keyboard behavior)
19. âœ… **Instance-level `_bindings` property** (not __init__ mutation, per-instance customization)
20. âœ… **CommandLink is stateful** (owns spinner, timers, but not command execution)
21. âœ… **Deterministic click behavior** (play/stop controls running, name opens output)
22. âœ… **Unified icon clicks** (mouse and keyboard follow same path, emit IconClicked)
23. âœ… **sanitize_id() utility** (centralized, reusable across widgets and user code)
24. âœ… **is_item_toggled()** (boolean getter, clearer than get_item_toggle)

---

## Implementation Plan (v0.4.0)

### Phase 1: Foundation
1. **Create `utils.py`** with `sanitize_id()` function
2. **Create `Icon` dataclass** with validation (required name, key conflict checks)
3. **Update `FileLink`**:
   - Add `display_name` parameter
   - Rename `Clicked` â†’ `Opened` message
   - Add `open_keys` parameter with `_bindings` property pattern
   - Update `DEFAULT_OPEN_KEYS` class attribute

### Phase 2: New Widgets
4. **Create `FileLinkWithIcons`** (new file: `file_link_with_icons.py`):
   - Compose FileLink with icon containers
   - Implement `icons_before`/`icons_after` layout
   - Add `update_icon()`, `set_icon_visible()`, `get_icon()` methods
   - Handle icon keyboard shortcuts via `Icon.key`

5. **Redesign `CommandLink`** (rewrite `command_link.py`):
   - Build own layout (don't inherit from anything complex)
   - Fixed layout: `[status/spinner] [â–¶ï¸/â¹ï¸] name [âš™ï¸?]`
   - Implement spinner animation
   - Auto-generate ID from name via `sanitize_id()`

6. **Create `FileLinkList`** (new file: `file_link_list.py`):
   - Inherit from `VerticalScroll`
   - Implement `show_toggles`/`show_remove` wrapping
   - ID validation (required, unique)
   - Toggle state management

### Phase 3: Cleanup & Testing
7. **Remove `ToggleableFileLink`** entirely
8. **Update `__init__.py`** exports:
   ```python
   from .file_link import FileLink
   from .file_link_with_icons import FileLinkWithIcons, Icon
   from .command_link import CommandLink
   from .file_link_list import FileLinkList
   from .utils import sanitize_id
   ```
9. **Write/update tests** for all new functionality
10. **Update demo scripts** to use new API
11. **Update README** with new API and migration examples

### Estimated File Changes

| File | Action |
|------|--------|
| `utils.py` | **New** |
| `file_link.py` | Modify |
| `file_link_with_icons.py` | **New** |
| `command_link.py` | Rewrite |
| `file_link_list.py` | **New** |
| `toggleable_file_link.py` | **Delete** |
| `__init__.py` | Update exports |
| `tests/*` | Update all |

---

Ready to start implementation?