# textual-filelink Final Architecture - As Implemented (v0.4.0)

## Design Principles

1. **Single Responsibility** - Each widget has one clear purpose
2. **Composition over Inheritance** - Build complex widgets from simple ones
3. **Display Only** - Widgets display state and emit events
   - **Exception**: FileLink executes commands to open files
4. **Explicit Over Implicit** - Clear, obvious APIs
5. **Fail Fast** - Catch errors at initialization, not runtime
6. **Breaking Changes Welcome** - Clean slate for better design (pre-1.0)
7. **Stateful UI Controllers** - CommandLink is a stateful UI controller (manages animation, state)

---

## Core Amendments (December 2024)

These amendments refine the original design and document implementation decisions:

1. **Keyboard bindings via runtime `bind()`** - Instance-level bindings set in `on_mount()` instead of `_bindings` property override
2. **FileLink.Clicked â†’ FileLink.Opened** - Better semantics, unified behavior
3. **Icon clicks unified** - Mouse and keyboard follow same path, emit IconClicked
4. **ID responsibilities** - FileLink: no auto-gen; CommandLink: auto-gen from name via `sanitize_id()`
5. **CommandLink is stateful** - Owns spinner, timers, running state (but not command execution)
6. **set_status(running: bool | None = None)** - Explicit control, no implicit changes
7. **FileLinkList requires IDs** - All items must have explicit IDs (fail fast on duplicates)
8. **add_item(toggled=False)** - Set initial state directly (no wrapper exposure)
9. **Click behavior** - Play/stop controls running; name opens output (if path set)
10. **Icon.name preserved** - Not renamed to `id` (avoids confusion)
11. **sanitize_id() utility** - Centralized ID sanitization (reusable across widgets)
12. **CommandLink is standalone** - Does NOT inherit from ToggleableFileLink (flat composition)
13. **ToggleableFileLink preserved** - Kept for backwards compatibility and convenience
14. **FileLinkList wraps items** - Uses internal `FileLinkListItem` wrapper (not exposed to users)

---

## Implementation Deviations from Original Plan

### Major Changes

1. **ToggleableFileLink NOT removed** - Preserved for backwards compatibility, still useful standalone widget
2. **CommandLink architecture** - Extends `Horizontal`, not a complex inheritance hierarchy
3. **Keyboard binding approach** - Uses runtime `bind()` in `on_mount()` instead of `_bindings` property
4. **FileLinkList wrapper** - Internal `FileLinkListItem` class handles layout, not exposed in public API
5. **Default settings visibility** - CommandLink `show_settings` defaults to `False` (not `True` as planned)

### Minor Adjustments

6. **Icon validation** - Happens in `__init__` with clear error messages
7. **CommandLink methods** - No `set_settings_tooltip()` method (tooltip set in constructor)
8. **FileLinkList methods** - Simplified API, no `set_item_toggle_by_index()` or `get_item_toggle()`
9. **Property names** - Consistent use of `is_toggled`, `is_running` (boolean getters)
10. **Message attributes** - CommandLink messages have `name` and `output_path` only (no `path`, no `is_toggled`)

---

## Core Classes

### 1. FileLink (Base Widget)

**Purpose**: Clickable filename that opens a file in an editor

**API**:
```python
class FileLink(Static, can_focus=True):
    """Clickable file link."""
    
    # Default keyboard shortcuts (can be overridden per instance)
    DEFAULT_OPEN_KEYS = ["enter", "o"]
    
    def __init__(
        self,
        path: Path | str,
        display_name: str | None = None,  # What's shown (defaults to path.name)
        *,
        line: int | None = None,
        column: int | None = None,
        command_builder: Callable | None = None,
        open_keys: list[str] | None = None,  # If None, uses DEFAULT_OPEN_KEYS
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
        _embedded: bool = False,  # Internal: disable focus for composed widgets
        tooltip: str | None = None,
    ):
```

**Properties**:
- `path: Path` - The actual file path
- `display_name: str` - What's shown to the user
- `line: int | None`
- `column: int | None`

**Methods**:
```python
def open_file(self) -> None
    """Execute the command to open the file and emit Opened event."""
```

**Messages**:
- `FileLink.Opened(path, line, column)` - Emitted after file opens
- `FileLink.Clicked` - **Deprecated** (backwards compatibility alias for Opened)

**Keyboard**:
- Default: `enter` or `o` to open file
- Customizable via `open_keys` parameter in constructor
- Set in `on_mount()` using runtime `bind()` API

**Implementation Note**:
Keyboard bindings are set dynamically in `on_mount()` rather than via `_bindings` property override:
```python
def on_mount(self) -> None:
    """Apply custom open_keys bindings at runtime."""
    if self._custom_open_keys is not None:
        for key in self._custom_open_keys:
            self._bindings.bind(key, "open_file", "Open file", show=False)
```

---

### 2. Icon (Data Class)

**Purpose**: Configuration for a single icon in FileLinkWithIcons

**API**:
```python
@dataclass
class Icon:
    """Configuration for an icon in FileLinkWithIcons."""
    
    name: str                      # REQUIRED: Unique identifier
    icon: str                      # REQUIRED: Unicode character
    tooltip: str | None = None     # Optional tooltip
    clickable: bool = False        # Posts IconClicked events?
    key: str | None = None         # Keyboard shortcut (e.g., "1", "s")
    visible: bool = True           # Initially visible?
    
    def __post_init__(self):
        """Validate icon configuration."""
        if not self.name:
            raise ValueError("Icon name cannot be empty")
        if not self.icon:
            raise ValueError("Icon character cannot be empty")
```

**Validation**:
- Icon names must be unique within a widget (checked at widget init)
- Icon keys must not conflict with widget bindings (checked at widget init)
- Icon keys must be unique among icons (checked at widget init)
- No auto-naming - name is required

---

### 3. FileLinkWithIcons (Composite Widget)

**Purpose**: FileLink with customizable icons before/after

**API**:
```python
class FileLinkWithIcons(Horizontal, can_focus=True):
    """FileLink with customizable icon indicators."""
    
    def __init__(
        self,
        path: Path | str,
        display_name: str | None = None,
        *,
        line: int | None = None,
        column: int | None = None,
        command_builder: Callable | None = None,
        icons_before: list[Icon] | None = None,
        icons_after: list[Icon] | None = None,
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
        tooltip: str | None = None,
    ):
```

**Layout**:
```
[icon1] [icon2] ... FileLink ... [icon3] [icon4]
 â””â”€ icons_before â”€â”˜             â””â”€ icons_after â”€â”€â”˜
```

**Properties**:
- `path: Path`
- `line: int | None`
- `column: int | None`
- `file_link: FileLink` - The internal FileLink widget (read-only)

**Methods**:
```python
def update_icon(self, name: str, **kwargs) -> None
    """Update icon properties. Raises ValueError if icon not found."""

def set_icon_visible(self, name: str, visible: bool) -> None
    """Show/hide icon. Raises ValueError if icon not found."""

def get_icon(self, name: str) -> Icon | None
    """Get icon by name. Returns None if not found."""
```

**Messages**:
- `FileLink.Opened(path, line, column)` - Inherited from embedded FileLink
- `FileLinkWithIcons.IconClicked(widget, path, icon_name, icon_char)` - When clickable icon clicked

**Keyboard**:
- `enter` or `o` - Open file (inherited)
- Custom keys from `Icon.key` - Set dynamically in `on_mount()`, trigger IconClicked

---

### 4. ToggleableFileLink (Preserved Widget)

**Status**: **Kept for backwards compatibility** (original plan was to remove it)

**Purpose**: FileLink with toggle checkbox, optional icons, and remove button

**API**:
```python
class ToggleableFileLink(Widget, can_focus=True):
    """FileLink with toggle, icons, and remove controls."""
    
    def __init__(
        self,
        path: Path | str,
        *,
        initial_toggle: bool = False,
        show_toggle: bool = True,
        show_remove: bool = True,
        icons: list[IconConfig | dict] | None = None,
        line: int | None = None,
        column: int | None = None,
        command_builder: Callable | None = None,
        disable_on_untoggle: bool = False,
        toggle_tooltip: str | None = None,
        remove_tooltip: str | None = None,
        link_tooltip: str | None = None,
        # Deprecated parameters
        status_icon: str | None = None,
        status_icon_clickable: bool = False,
        status_tooltip: str | None = None,
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
    ):
```

**Note**: Uses `IconConfig` dataclass (not `Icon`) for its icons configuration. This maintains backwards compatibility while FileLinkWithIcons uses the newer `Icon` class.

**Properties**:
- `path: Path`
- `is_toggled: bool`
- `icons: list[dict]` - Icon configurations as dicts
- `file_link: FileLink` - Internal FileLink widget

**Messages**:
- `ToggleableFileLink.Toggled(path, is_toggled)`
- `ToggleableFileLink.Removed(path)`
- `ToggleableFileLink.IconClicked(path, icon_name, icon)`

---

### 5. CommandLink (Specialized Widget)

**Purpose**: Command orchestration with play/stop, status, and settings

**Architecture**: Standalone widget extending `Horizontal` (flat composition, not inheritance from ToggleableFileLink)

**API**:
```python
class CommandLink(Horizontal, can_focus=True):
    """Command control widget."""
    
    # Default keyboard shortcuts (can be overridden per instance)
    DEFAULT_OPEN_KEYS = ["enter", "o"]
    DEFAULT_PLAY_STOP_KEYS = ["space", "p"]
    DEFAULT_SETTINGS_KEYS = ["s"]
    
    # Spinner frames for animation
    SPINNER_FRAMES = ["â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "]
    
    def __init__(
        self,
        name: str,                          # Command display name
        *,
        output_path: Path | str | None = None,
        command_builder: Callable | None = None,
        initial_status_icon: str = "â—‹",
        initial_status_tooltip: str | None = None,
        show_settings: bool = False,        # Note: defaults to False
        open_keys: list[str] | None = None,
        play_stop_keys: list[str] | None = None,
        settings_keys: list[str] | None = None,
        id: str | None = None,              # Auto-generated from name if None
        classes: str | None = None,
    ):
```

**Fixed Layout**:
```
[status/spinner] [â–¶ï¸/â¸ï¸] name [âš™ï¸?]
```

Components:
- **Status/Spinner**: Status icon OR animated spinner (when running)
- **â–¶ï¸/â¸ï¸**: Play button (stopped) or Stop button (running)
- **Name**: Command name (clickable FileLink if output_path set, else Static)
- **âš™ï¸**: Optional settings button (only if show_settings=True)

**Properties**:
- `name: str` - Command display name
- `output_path: Path | None` - Output file path
- `is_running: bool` - Current running state

**Methods**:
```python
def set_status(
    self,
    *,
    icon: str | None = None,
    running: bool | None = None,
    tooltip: str | None = None,
) -> None:
    """Update command status display."""

def set_output_path(self, output_path: Path | str | None) -> None:
    """Set or update the output file path."""
```

**Messages**:
- `CommandLink.PlayClicked(name, output_path)` - When play button clicked
- `CommandLink.StopClicked(name, output_path)` - When stop button clicked
- `CommandLink.SettingsClicked(name, output_path)` - When settings icon clicked
- `CommandLink.OutputClicked(output_path)` - When command name clicked (if output_path set)

**Note**: Messages do NOT include `is_toggled` or `path` attributes (CommandLink has no toggle functionality)

**Widget ID**:
- Auto-generated from name if `id=None`: `CommandLink("Run Tests")` â†’ `id="run-tests"`
- Uses `sanitize_id()` utility internally

**Keyboard Bindings**:
Set dynamically in `on_mount()` using runtime `bind()` API:
```python
def on_mount(self) -> None:
    """Set up runtime keyboard bindings."""
    open_keys = self._custom_open_keys if self._custom_open_keys is not None else self.DEFAULT_OPEN_KEYS
    for key in open_keys:
        self._bindings.bind(key, "open_output", "Open output", show=False)
    # ... similar for play_stop_keys and settings_keys
```

---

### 6. FileLinkList (Container Widget)

**Purpose**: Scrollable container for file links with optional uniform controls

**API**:
```python
class FileLinkList(VerticalScroll):
    """Scrollable file/command list container."""
    
    def __init__(
        self,
        *,
        show_toggles: bool = False,
        show_remove: bool = False,
        id: str | None = None,
        classes: str | None = None,
    ):
```

**Internal Implementation**:
Uses `FileLinkListItem` wrapper class (not exposed to users):
```python
class FileLinkListItem(Horizontal):
    """Internal wrapper for items in FileLinkList.
    
    Layout: [toggle?] item [remove?]
    """
```

**Properties**:
- `len(file_list)` - Number of items
- Iterable: `for item in file_list: ...`

**Methods**:
```python
def add_item(self, item: Widget, *, toggled: bool = False) -> None:
    """Add item. Raises ValueError if item has no ID or duplicate ID."""

def remove_item(self, item: Widget) -> None:
    """Remove item from list."""

def clear_items(self) -> None:
    """Remove all items."""

def toggle_all(self, value: bool) -> None:
    """Set all toggle checkboxes to same value."""

def remove_selected(self) -> None:
    """Remove all toggled items."""

def get_toggled_items(self) -> list[Widget]:
    """Get all currently toggled items."""

def get_items(self) -> list[Widget]:
    """Get all items in the list."""
```

**Messages**:
- `FileLinkList.ItemToggled(item, is_toggled)` - When item toggle changes
- `FileLinkList.ItemRemoved(item)` - When item removed
- Plus all messages from child items (bubbled up)

**ID Validation**:
- All items MUST have explicit IDs (raises `ValueError` if missing)
- Duplicate IDs raise `ValueError` (fail fast)

**Example**:
```python
file_list = FileLinkList(show_toggles=True, show_remove=True)

# Items need explicit IDs
file_list.add_item(FileLink("test.py", id="test-py"), toggled=True)
file_list.add_item(CommandLink("Build", id="cmd-build"))  # CommandLink auto-generates ID

# Error cases (fail fast)
file_list.add_item(FileLink("file.py"))  # âœ— ValueError: ID required
file_list.add_item(FileLink("dup.py", id="test-py"))  # âœ— ValueError: Duplicate ID
```

---

## Utility Functions

### sanitize_id()

**Purpose**: Convert names to valid widget IDs

**API**:
```python
def sanitize_id(name: str) -> str:
    """Convert name to valid widget ID.
    
    Sanitizes for use as Textual widget ID: lowercase, spacesâ†’hyphens,
    path separatorsâ†’hyphens, keep only alphanumeric/hyphens/underscores.
    
    Examples
    --------
    >>> sanitize_id("Run Tests")
    'run-tests'
    >>> sanitize_id("src/main.py")
    'src-main-py'
    >>> sanitize_id("Build Project!")
    'build-project-'
    >>> sanitize_id("src\\file.py")
    'src-file-py'
    """
```

**Usage**:
```python
from textual_filelink import sanitize_id

# User code
file_list.add_item(FileLink(path, id=sanitize_id(str(path))))

# Internal (CommandLink)
widget_id = id or sanitize_id(name)
```

---

## Implementation Details

### Keyboard Binding Strategy

**Approach**: Runtime `bind()` in `on_mount()` instead of `_bindings` property override

**Rationale**:
- Cleaner separation: constructor stores parameters, `on_mount()` applies them
- No need for property override pattern
- Works consistently across all widget types

**Implementation**:
```python
class FileLink(Static, can_focus=True):
    DEFAULT_OPEN_KEYS = ["enter", "o"]
    
    def __init__(self, path, *, open_keys=None, ...):
        super().__init__(...)
        self._custom_open_keys = open_keys
    
    def on_mount(self) -> None:
        """Apply custom open_keys bindings at runtime."""
        if self._custom_open_keys is not None:
            for key in self._custom_open_keys:
                self._bindings.bind(key, "open_file", "Open file", show=False)
```

### Event Semantics

**FileLink.Opened** (was Clicked):
```python
def on_click(self, event):
    """Mouse click handler."""
    event.stop()
    self.open_file()

def action_open_file(self):
    """Keyboard action handler."""
    self.open_file()

def open_file(self):
    """Single source of truth for opening files."""
    self._do_open_file()
    self.post_message(self.Opened(self._path, self._line, self._column))
```

### Spinner Animation (CommandLink)

```python
SPINNER_FRAMES = ["â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "]

def set_status(self, *, running: bool | None = None, ...):
    if running is not None:
        was_running = self._command_running
        self._command_running = running
        
        if running and not was_running:
            # Start spinner
            self._spinner_frame_index = 0
            self._spinner_timer = self.set_interval(0.1, self._animate_spinner)
        elif not running and was_running:
            # Stop spinner
            if self._spinner_timer:
                self._spinner_timer.stop()
                self._spinner_timer = None

def _animate_spinner(self) -> None:
    """Update spinner frame."""
    if self._command_running:
        frame = self.SPINNER_FRAMES[self._spinner_frame_index]
        self._status_widget.update(frame)
        self._spinner_frame_index = (self._spinner_frame_index + 1) % len(self.SPINNER_FRAMES)
```

### Icon Validation (FileLinkWithIcons)

```python
def _validate_icons(self) -> None:
    """Validate icon configuration (fail fast on errors)."""
    all_icons = self._icons_before + self._icons_after
    
    # Check for duplicate names
    names = [icon.name for icon in all_icons]
    if len(names) != len(set(names)):
        duplicates = [name for name in names if names.count(name) > 1]
        raise ValueError(f"Duplicate icon names: {set(duplicates)}")
    
    # Check for duplicate keys (excluding None)
    keys = [icon.key for icon in all_icons if icon.key is not None]
    if len(keys) != len(set(keys)):
        duplicates = [key for key in keys if keys.count(key) > 1]
        raise ValueError(f"Duplicate icon keys: {set(duplicates)}")
    
    # Check for conflicts with FileLink bindings
    filelink_keys = {"o", "enter"}
    for icon in all_icons:
        if icon.key in filelink_keys:
            raise ValueError(
                f"Icon key '{icon.key}' conflicts with FileLink binding. "
                f"Reserved keys: {filelink_keys}"
            )
```

### FileLinkList Implementation

**Internal Wrapper** (not exposed):
```python
class FileLinkListItem(Horizontal):
    """Internal wrapper widget for items in FileLinkList."""
    
    def __init__(
        self,
        item: Widget,
        *,
        show_toggle: bool = False,
        show_remove: bool = False,
        initial_toggle: bool = False,
    ):
        # Layout: [toggle?] item [remove?]
```

**ID Validation**:
```python
def add_item(self, item: Widget, *, toggled: bool = False) -> None:
    # Validate ID exists
    if not item.id:
        raise ValueError(f"Item must have an explicit ID set. Got: {item}")
    
    # Validate ID is unique
    if item.id in self._item_ids:
        raise ValueError(f"Duplicate item ID: {item.id}")
    
    # Track ID
    self._item_ids.add(item.id)
    
    # Create and mount wrapper
    wrapper = FileLinkListItem(item, ...)
    self.mount(wrapper)
```

---

## Version & Breaking Changes

**Version**: 0.4.0

Per [semver](https://semver.org/), versions before 1.0.0 may introduce breaking changes in any release.

**Changes in 0.4.0**:
- **Breaking**: `FileLink.Clicked` â†’ `FileLink.Opened` (Clicked kept for backwards compatibility)
- **Breaking**: CommandLink does NOT inherit from ToggleableFileLink (standalone widget)
- **Breaking**: CommandLink messages have only `name` and `output_path` (no `is_toggled`)
- **Breaking**: FileLinkList requires explicit IDs for all items
- **New**: `FileLinkWithIcons` widget with `Icon` dataclass
- **New**: `FileLinkList` container widget
- **New**: `sanitize_id()` utility function
- **New**: Per-instance keyboard shortcut customization
- **Preserved**: `ToggleableFileLink` (for backwards compatibility)

---

## Summary of Key Decisions

### Implemented as Planned
1. âœ… **FileLink opens files** (exception to display-only rule)
2. âœ… **CommandLink builds its own layout** (standalone, not inherited)
3. âœ… **Icon.name is required** (no auto-naming)
4. âœ… **Fail fast on duplicate names/keys**
5. âœ… **set_status(running: bool | None = None)** (explicit control)
6. âœ… **Widget ID sanitization** (CommandLink auto-generates from name)
7. âœ… **Custom keyboard shortcuts** (per-instance customization)
8. âœ… **FileLinkList is scrollable** (inherits from VerticalScroll)
9. âœ… **Uniform wrapping** (FileLinkList treats all widget types the same)
10. âœ… **add_item(toggled=False)** (set initial toggle state directly)
11. âœ… **FileLinkList requires IDs** (fail fast on missing or duplicate IDs)
12. âœ… **FileLink.Opened event** (was Clicked, unified mouse/keyboard behavior)
13. âœ… **CommandLink is stateful** (owns spinner, timers)
14. âœ… **sanitize_id() utility** (centralized, reusable)

### Implementation Deviations
15. âœ… **ToggleableFileLink preserved** (not removed as planned - backwards compatibility)
16. âœ… **Keyboard bindings via on_mount()** (not `_bindings` property override)
17. âœ… **FileLinkListItem wrapper** (internal class, not exposed)
18. âœ… **CommandLink show_settings defaults to False** (not True as planned)
19. âœ… **Simplified FileLinkList API** (no index-based methods)
20. âœ… **CommandLink message attributes** (name + output_path only, no path or is_toggled)

---

## Implementation Status

### Completed âœ…
- [x] Create `utils.py` with `sanitize_id()` function
- [x] Create `Icon` dataclass with validation
- [x] Update `FileLink` with `display_name`, `Opened` message, custom keys
- [x] Create `FileLinkWithIcons` widget
- [x] Redesign `CommandLink` as standalone widget
- [x] Create `FileLinkList` container widget
- [x] Preserve `ToggleableFileLink` for backwards compatibility
- [x] Update `__init__.py` exports
- [x] Write comprehensive tests
- [x] Update README documentation

### File Changes

| File | Status |
|------|--------|
| `utils.py` | âœ… Created |
| `file_link.py` | âœ… Modified |
| `icon.py` | âœ… Created |
| `file_link_with_icons.py` | âœ… Created |
| `command_link.py` | âœ… Rewritten |
| `file_link_list.py` | âœ… Created |
| `toggleable_file_link.py` | âœ… Preserved (not deleted) |
| `__init__.py` | âœ… Updated |
| `tests/*` | âœ… Updated |
| `README.md` | âœ… Updated |

---

## API Stability Notes

**Pre-1.0 Status**: Breaking changes may occur in minor versions

**Stable APIs** (unlikely to change):
- `FileLink` core functionality
- `Icon` dataclass
- `sanitize_id()` utility
- Message names and basic attributes

**Evolving APIs** (may change):
- CommandLink message attributes (might add more context)
- FileLinkList batch operations (might add more features)
- Keyboard shortcut customization (might add more flexibility)

---

Ready for v0.4.0 release! ðŸš€